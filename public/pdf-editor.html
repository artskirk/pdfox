<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFOX - Professional PDF Editor</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- pdf-lib Library -->
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <!-- Signature Pad Library -->
    <script src="https://cdn.jsdelivr.net/npm/signature_pad@5.0.3/dist/signature_pad.umd.min.js"></script>

    <!-- Google Fonts for Handwriting Signatures + Bebas Neue for Netflix Branding -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Pacifico&family=Sacramento&family=Bebas+Neue&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Custom Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #141414;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 10px;
            border: 2px solid #141414;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #E50914;
        }

        ::-webkit-scrollbar-corner {
            background: #141414;
        }

        /* Firefox Scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: #333 #141414;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000000;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            color: #ffffff;
        }

        .header {
            background: #000000;
            color: white;
            padding: 20px 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 100;
            border-bottom: 1px solid #141414;
        }

        .header h1 {
            font-size: 36px;
            font-weight: 900;
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 2px;
            position: relative;
            margin: 0;
            font-family: 'Bebas Neue', sans-serif;
            color: #E50914;
            text-shadow: 2px 2px 4px rgba(229, 9, 20, 0.5);
        }

        .header-logo-link {
            color: #E50914;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .header-logo-link:hover {
            opacity: 0.85;
        }

        .header-actions {
            display: flex;
            gap: 15px;
        }

        .header-btn {
            background: #808080;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            position: relative;
            font-size: 15px;
        }

        .header-btn:hover {
            background: #606060;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
        }

        .header-btn.primary {
            background: #E50914;
            color: white;
            box-shadow: 0 3px 12px rgba(229, 9, 20, 0.4);
        }

        .header-btn.primary:hover {
            background: #C40812;
            box-shadow: 0 5px 18px rgba(229, 9, 20, 0.5);
        }

        .toolbar {
            background: #141414;
            padding: 18px 35px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.8);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            border-bottom: 1px solid #222;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            padding: 5px;
            border-right: 1px solid #333;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-btn {
            background: #2a2a2a;
            border: 2px solid transparent;
            padding: 12px 18px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }

        .tool-btn:hover {
            background: #3a3a3a;
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.6);
        }

        .tool-btn.active {
            background: #E50914;
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.5);
            transform: translateY(0);
        }

        .tool-label {
            font-size: 13px;
            font-weight: 500;
            color: #aaaaaa;
            margin-right: 10px;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: 2px solid #DDD;
            border-radius: 6px;
            cursor: pointer;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            background: #1a1a1a;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 50px;
        }

        .pdf-viewer {
            position: relative;
            background: white;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            max-width: 100%;
            border-radius: 8px;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
        }

        .pdf-viewer:hover {
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.2);
        }

        #pdfCanvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        #annotationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0;
            line-height: 1.0;
            pointer-events: none;
        }

        #textLayer.editable {
            opacity: 1;
            pointer-events: auto;
        }

        #overlayLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: visible;
            pointer-events: none;
            z-index: 50;
        }

        #overlayLayer > * {
            pointer-events: auto;
        }

        #textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: pointer;
            transform-origin: 0% 0%;
            padding: 2px;
            margin: -2px;
            text-indent: 0;
            letter-spacing: 0;
            word-spacing: 0;
        }

        #textLayer.editable > span:hover {
            background: rgba(255, 255, 0, 0.5);
            outline: 2px solid rgba(220, 31, 38, 0.5);
        }

        #textLayer > span.edited {
            background: rgb(255, 255, 255) !important; /* Fully opaque white to cover original text */
            color: #1a1a1a !important;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4); /* Green border to indicate edited */
            border: 1px solid rgba(76, 175, 80, 0.5);
            padding: 4px 6px !important;
            margin: -4px -6px !important;
            cursor: move !important;
            user-select: none;
        }

        #textLayer > span.edited.dragging {
            opacity: 0.7;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.6);
            z-index: 1000 !important;
        }

        /* Text Overlays (OCR-extracted text positioned over PDF) */
        .text-overlay {
            position: absolute;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(33, 150, 243, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: move;
            user-select: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            transition: all 0.2s ease;
            z-index: 100;
        }

        .text-overlay:hover {
            border-color: rgba(33, 150, 243, 0.8);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
        }

        .text-overlay.selected {
            border-color: #2196F3;
            border-width: 3px;
            box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
            z-index: 200;
        }

        .text-overlay .delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 24px;
            height: 24px;
            background: #DC1F26;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 201;
        }

        .text-overlay.selected .delete-btn {
            display: flex;
        }

        .text-overlay.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #2196F3;
            border: 2px solid white;
            border-radius: 50%;
            display: none;
            z-index: 202;
        }

        .text-overlay.selected .resize-handle {
            display: block;
        }

        .resize-handle.se {
            bottom: -5px;
            right: -5px;
            cursor: nwse-resize;
        }

        .resize-handle.sw {
            bottom: -5px;
            left: -5px;
            cursor: nesw-resize;
        }

        .resize-handle.ne {
            top: -5px;
            right: -5px;
            cursor: nesw-resize;
        }

        .resize-handle.nw {
            top: -5px;
            left: -5px;
            cursor: nwse-resize;
        }

        /* Edge resize handles */
        .resize-handle.n {
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .resize-handle.s {
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .resize-handle.e {
            top: 50%;
            right: -5px;
            transform: translateY(-50%);
            cursor: ew-resize;
        }

        .resize-handle.w {
            top: 50%;
            left: -5px;
            transform: translateY(-50%);
            cursor: ew-resize;
        }

        /* Overlay list in sidebar */
        .overlay-list-item {
            padding: 10px;
            margin: 8px 0;
            background: #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 13px;
            color: #ffffff;
        }

        .overlay-list-item:hover {
            background: #3a3a3a;
        }

        .overlay-list-item.active {
            background: rgba(229, 9, 20, 0.2);
            border: 2px solid #E50914;
        }

        .overlay-list-item .overlay-text-preview {
            color: #aaaaaa;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 4px;
        }

        .sidebar {
            width: 320px;
            background: #141414;
            padding: 25px;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.8);
            overflow-y: auto;
            border-left: 1px solid #222;
        }

        .sidebar h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #ffffff;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-label {
            font-size: 14px;
            font-weight: 500;
            color: #aaaaaa;
            margin-bottom: 8px;
            display: block;
        }

        .property-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 14px;
            background: #2a2a2a;
            color: #ffffff;
        }

        .page-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 15px 30px;
            background: #141414;
            border-top: 1px solid #222;
        }

        .page-btn {
            background: #2a2a2a;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }

        .page-btn:hover {
            background: #3a3a3a;
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.6);
        }

        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        .page-info {
            font-size: 14px;
            color: #aaaaaa;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: fadeInScale 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid #333;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .spinner {
            border: 5px solid rgba(229, 9, 20, 0.2);
            border-top: 5px solid #E50914;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            margin: 0 auto 24px;
            box-shadow: 0 4px 15px rgba(229, 9, 20, 0.3);
        }

        .loading-content > div:last-child {
            color: #ffffff;
            font-size: 17px;
            font-weight: 500;
            letter-spacing: 0.2px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 12px rgba(220, 31, 38, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(220, 31, 38, 0.5);
            }
        }

        .edit-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 1001;
            min-width: 400px;
            display: none;
            border: 1px solid #333;
        }

        .edit-modal.active {
            display: block;
        }

        .edit-modal h3 {
            margin-bottom: 15px;
            color: #ffffff;
        }

        .edit-modal textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #E50914;
            border-radius: 4px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            resize: vertical;
            background: #2a2a2a;
            color: #ffffff;
        }

        .edit-modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }

        .edit-modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 14px;
        }

        .edit-modal-btn:hover {
            transform: translateY(-1px);
        }

        .edit-modal-btn.primary {
            background: #E50914;
            color: white;
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.4);
        }

        .edit-modal-btn.primary:hover {
            background: #C40812;
            box-shadow: 0 6px 18px rgba(229, 9, 20, 0.5);
        }

        .edit-modal-btn.secondary {
            background: #2a2a2a;
            color: #ffffff;
            border: 2px solid #333;
        }

        .edit-modal-btn.secondary:hover {
            background: #3a3a3a;
            border-color: #444;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
        }

        .modal-overlay.active {
            display: block;
        }

        /* Custom Modal Styles */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .custom-modal-content {
            background: #1a1a1a;
            border-radius: 16px;
            padding: 32px;
            max-width: 440px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            border: 1px solid #333;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-icon {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-icon svg {
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
        }

        .modal-message {
            font-size: 16px;
            line-height: 1.6;
            color: #ffffff;
            margin-bottom: 28px;
            white-space: pre-line;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 32px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 100px;
        }

        .modal-btn-primary {
            background: #E50914;
            color: white;
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.4);
        }

        .modal-btn-primary:hover {
            background: #C40812;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(229, 9, 20, 0.5);
        }

        .modal-btn-secondary {
            background: #2a2a2a;
            color: #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }

        .modal-btn-secondary:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
        }

        .modal-btn:active {
            transform: translateY(0);
        }

        /* Signature Modal Styles */
        .signature-modal-content {
            background: #1a1a1a;
            border-radius: 16px;
            padding: 0;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            border: 1px solid #333;
        }

        .signature-modal-header {
            padding: 24px 24px 16px;
            border-bottom: 2px solid #333;
        }

        .signature-modal-header h2 {
            font-size: 24px;
            color: #ffffff;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .signature-tabs {
            display: flex;
            gap: 8px;
            padding: 0 24px;
            background: #0a0a0a;
        }

        .signature-tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #aaaaaa;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }

        .signature-tab:hover {
            color: #E50914;
            background: rgba(229, 9, 20, 0.1);
        }

        .signature-tab.active {
            color: #E50914;
            border-bottom-color: #E50914;
            background: #1a1a1a;
        }

        .signature-tab-content {
            display: none;
            padding: 24px;
            flex: 1;
            overflow-y: auto;
        }

        .signature-tab-content.active {
            display: block;
        }

        /* Draw Tab Styles */
        .signature-canvas-container {
            border: 2px solid #333;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        #signatureCanvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }

        .signature-canvas-controls {
            margin-top: 16px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Type Tab Styles */
        .type-signature-input {
            width: 100%;
            padding: 16px;
            font-size: 32px;
            border: 2px solid #333;
            border-radius: 12px;
            margin-bottom: 20px;
            transition: border-color 0.2s;
            background: #2a2a2a;
            color: #ffffff;
        }

        .type-signature-input:focus {
            outline: none;
            border-color: #E50914;
        }

        .font-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .font-option {
            padding: 20px 16px;
            border: 2px solid #333;
            border-radius: 12px;
            background: #2a2a2a;
            cursor: pointer;
            text-align: center;
            font-size: 24px;
            transition: all 0.2s;
            color: #ffffff;
        }

        .font-option:hover {
            border-color: #E50914;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.3);
        }

        .font-option.selected {
            border-color: #E50914;
            background: rgba(229, 9, 20, 0.1);
        }

        .signature-color-picker {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .signature-color-picker label {
            font-weight: 500;
            color: #ffffff;
        }

        .signature-color-picker input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
        }

        /* Upload Tab Styles */
        .upload-area {
            border: 3px dashed #333;
            border-radius: 16px;
            padding: 48px 24px;
            text-align: center;
            background: #0a0a0a;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #E50914;
            background: rgba(229, 9, 20, 0.1);
        }

        .upload-area.drag-over {
            border-color: #E50914;
            background: rgba(229, 9, 20, 0.15);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: #E50914;
        }

        .upload-text {
            font-size: 16px;
            color: #aaaaaa;
            margin-bottom: 8px;
        }

        .upload-hint {
            font-size: 13px;
            color: #777;
        }

        #signatureFileInput {
            display: none;
        }

        .signature-preview-container {
            margin-top: 24px;
            display: none;
        }

        .signature-preview {
            max-width: 100%;
            max-height: 200px;
            border: 2px solid #333;
            border-radius: 12px;
            padding: 16px;
            background: #2a2a2a;
        }

        .signature-modal-footer {
            padding: 16px 24px;
            border-top: 2px solid #333;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            background: #1a1a1a;
        }
    </style>
</head>
<body>
    <header class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
            <h1>
                <a href="/" class="header-logo-link">
                <svg width="36" height="36" viewBox="0 0 48 48" fill="none" style="display: inline-block; vertical-align: middle;" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <!-- Gradient for document -->
                        <linearGradient id="docGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#E50914;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#C40812;stop-opacity:1" />
                        </linearGradient>
                        <!-- Gradient for edit badge -->
                        <linearGradient id="editGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#E50914;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#B00610;stop-opacity:1" />
                        </linearGradient>
                        <!-- Shadow filter -->
                        <filter id="docShadow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceAlpha" stdDeviation="1.5"/>
                            <feOffset dx="0" dy="2" result="offsetblur"/>
                            <feComponentTransfer>
                                <feFuncA type="linear" slope="0.5"/>
                            </feComponentTransfer>
                            <feMerge>
                                <feMergeNode/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                        <!-- Glow filter -->
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>

                    <!-- Main document body -->
                    <rect x="8" y="6" width="28" height="36" rx="3" fill="url(#docGradient)" filter="url(#docShadow)" stroke="rgba(229,9,20,0.8)" stroke-width="1.5"/>

                    <!-- Folded corner (top-right) -->
                    <path d="M36 6 L36 12 L30 12 L36 6 Z" fill="rgba(196,8,18,0.7)"/>
                    <path d="M36 6 L36 12 L30 12" stroke="rgba(229,9,20,0.9)" stroke-width="1" fill="none"/>

                    <!-- PDF text lines -->
                    <line x1="14" y1="16" x2="30" y2="16" stroke="rgba(255,255,255,0.8)" stroke-width="2" stroke-linecap="round"/>
                    <line x1="14" y1="21" x2="28" y2="21" stroke="rgba(255,255,255,0.8)" stroke-width="2" stroke-linecap="round"/>
                    <line x1="14" y1="26" x2="30" y2="26" stroke="rgba(255,255,255,0.8)" stroke-width="2" stroke-linecap="round"/>
                    <line x1="14" y1="31" x2="24" y2="31" stroke="rgba(255,255,255,0.8)" stroke-width="2" stroke-linecap="round"/>

                    <!-- Edit badge with pen icon -->
                    <circle cx="36" cy="36" r="9" fill="url(#editGradient)" filter="url(#glow)" stroke="rgba(255,255,255,0.9)" stroke-width="2"/>

                    <!-- Pen icon -->
                    <path d="M32 36 L36 32 L38 34 L34 38 Z" fill="white" opacity="0.95"/>
                    <path d="M38 34 L39 33 L40 34 L39 35 Z" fill="white" opacity="0.95"/>
                    <line x1="32" y1="38" x2="31" y2="39" stroke="white" stroke-width="1.5" stroke-linecap="round" opacity="0.9"/>
                </svg>
                PDFOX
                </a>
            </h1>
        </div>
        <div class="header-actions">
            <button class="header-btn" onclick="document.getElementById('openFileInput').click()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px;">
                    <path d="M13 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V9z" stroke="currentColor" stroke-width="2"/>
                    <path d="M13 2v7h7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M9 15l3-3 3 3M12 12v7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                Open File
            </button>
            <button class="header-btn" onclick="goBack()">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" style="display: inline-block; margin-right: 6px;">
                    <path d="M10 12L6 8l4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                Back
            </button>
            <button class="header-btn primary" onclick="savePDF()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px;">
                    <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z" stroke="white" stroke-width="2"/>
                    <path d="M7 13l3 3 7-7" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                Save PDF
            </button>
        </div>
    </header>

    <!-- Hidden file input for opening new PDFs -->
    <input type="file" id="openFileInput" accept=".pdf" style="display: none;">

    <div class="toolbar">
        <div class="tool-group">
            <button class="tool-btn active" id="editTextTool" onclick="setTool('editText')" title="Edit Text (Click on text to modify)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <small>Edit Text</small>
            </button>
            <button class="tool-btn" id="addTextTool" onclick="setTool('addText')" title="Add New Text">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/>
                    <path d="M8 3h8M12 3v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                <small>Add Text</small>
            </button>
            <button class="tool-btn" id="moveTextTool" onclick="setTool('moveText')" title="Move Text (Drag edited text to reposition)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <circle cx="12" cy="12" r="2" fill="currentColor"/>
                </svg>
                <small>Move Text</small>
            </button>
            <button class="tool-btn" id="ocrSelectTool" onclick="setTool('ocrSelect')" title="Select Text (Drag to select area for text extraction)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2" stroke-dasharray="4 2"/>
                    <path d="M8 12h8M12 8v8" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                <small>Select Text</small>
            </button>
            <button class="tool-btn" id="eraseTool" onclick="setTool('erase')" title="Erase (Permanently remove content from document)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M4 6h16v2H4z" fill="currentColor"/>
                    <path d="M5 16l2-8h10l2 8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                    <rect x="7" y="16" width="10" height="5" rx="1" fill="currentColor"/>
                    <path d="M9 8l3-4 3 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <small>Erase</small>
            </button>
        </div>

        <div class="tool-group">
            <button class="tool-btn" id="drawTool" onclick="setTool('draw')" title="Draw">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M12 19l7 2-2-7-7-7-5 5 7 7z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <button class="tool-btn" id="rectangleTool" onclick="setTool('rectangle')" title="Rectangle">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <rect x="3" y="6" width="18" height="12" rx="2" stroke="currentColor" stroke-width="2"/>
                </svg>
            </button>
            <button class="tool-btn" id="circleTool" onclick="setTool('circle')" title="Circle">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <circle cx="12" cy="12" r="8" stroke="currentColor" stroke-width="2"/>
                </svg>
            </button>
        </div>

        <div class="tool-group">
            <button class="tool-btn" id="signatureTool" onclick="openSignatureModal()" title="Add Signature">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M3 17l2.5-2.5M6 10l4-4 4 4-4 4-4-4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14 14l4.5 4.5M18.5 18.5L21 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M3 21h4.5" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/>
                </svg>
                <small>Signature</small>
            </button>
        </div>

        <div class="tool-group">
            <span class="tool-label">Color:</span>
            <input type="color" id="colorPicker" class="color-picker" value="#DC1F26">
        </div>

        <div class="tool-group">
            <span class="tool-label">Size:</span>
            <input type="range" id="brushSize" min="1" max="10" value="3" style="width: 100px;">
            <span id="sizeValue">3</span>
        </div>

        <div class="tool-group">
            <button class="tool-btn" onclick="undo()" title="Undo">
                <span>↶</span>
            </button>
        </div>
    </div>

    <div class="main-content">
        <div class="canvas-container">
            <div class="pdf-viewer" id="pdfViewer">
                <canvas id="pdfCanvas"></canvas>
                <div id="textLayer"></div>
                <div id="overlayLayer"></div>
                <canvas id="annotationCanvas"></canvas>
            </div>
        </div>

        <div class="sidebar">
            <h3>Properties</h3>

            <div class="property-group">
                <label class="property-label">Document Name:</label>
                <input type="text" id="docName" class="property-input" value="Edited PDF">
            </div>

            <div class="property-group">
                <label class="property-label">Font Size:</label>
                <input type="number" id="fontSize" class="property-input" value="12" min="6" max="72">
            </div>

            <div class="property-group">
                <label class="property-label">Text Color:</label>
                <input type="color" id="textColor" class="property-input" value="#000000">
            </div>

            <div class="property-group">
                <h4 style="margin-bottom: 10px; color: #666;">Instructions:</h4>
                <ul style="font-size: 13px; line-height: 1.8; color: #666;">
                    <li><strong>Edit Text:</strong> Click on any text to modify it</li>
                    <li><strong>Add Text:</strong> Click anywhere to add new text</li>
                    <li><strong>Draw:</strong> Freehand drawing tool</li>
                    <li><strong>Shapes:</strong> Add rectangles and circles</li>
                    <li><strong>Save:</strong> Download your edited PDF</li>
                </ul>
            </div>

            <div class="property-group">
                <h4 style="margin-bottom: 10px; color: #2196F3;">Text Overlays:</h4>
                <div id="overlayList" style="max-height: 200px; overflow-y: auto;">
                    <em style="font-size: 12px; color: #666;">No overlays yet</em>
                </div>
            </div>

            <div class="property-group">
                <h4 style="margin-bottom: 10px; color: #DC1F26;">Edited Text Items:</h4>
                <div id="editedTextList" style="font-size: 12px; color: #666; max-height: 200px; overflow-y: auto;">
                    <em>No text edited yet</em>
                </div>
            </div>
        </div>
    </div>

    <div class="page-controls">
        <button class="page-btn" id="prevPage" onclick="changePage(-1)">◀ Previous</button>
        <span class="page-info">Page <span id="currentPage">1</span> of <span id="totalPages">1</span></span>
        <button class="page-btn" id="nextPage" onclick="changePage(1)">Next ▶</button>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>

    <!-- Edit Text Modal -->
    <div id="editModal" class="custom-modal" style="display: none;">
        <div class="custom-modal-content" style="max-width: 500px; text-align: left;">
            <div style="margin-bottom: 20px;">
                <h3 style="font-size: 22px; color: #ffffff; margin: 0 0 8px 0; display: flex; align-items: center; gap: 10px;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" stroke="#DC1F26" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Edit Text
                </h3>
                <p style="font-size: 13px; color: #999; margin: 0;">
                    Original: <span id="originalText" style="color: #ccc; font-style: italic;"></span>
                </p>
            </div>
            <textarea id="editTextArea" style="width: 100%; min-height: 120px; padding: 12px; border: 2px solid #333; border-radius: 8px; font-size: 14px; font-family: Arial, sans-serif; resize: vertical; background: #2a2a2a; color: #ffffff; transition: border-color 0.3s; box-sizing: border-box;" onfocus="this.style.borderColor='#DC1F26'" onblur="this.style.borderColor='#333'"></textarea>
            <div class="modal-actions" style="margin-top: 20px;">
                <button class="modal-btn modal-btn-secondary" onclick="closeEditModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="saveTextEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- OCR Results Panel -->
    <div class="edit-modal" id="ocrResultsModal" style="max-width: 650px;">
        <h3 style="display: flex; align-items: center; gap: 10px;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                <rect x="3" y="3" width="18" height="18" rx="2" stroke="#DC1F26" stroke-width="2" stroke-dasharray="4 2"/>
                <path d="M8 12h8M12 8v8" stroke="#DC1F26" stroke-width="2" stroke-linecap="round"/>
            </svg>
            OCR Extracted Text
        </h3>
        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
            Area: <span id="ocrAreaInfo"></span>
        </p>
        <textarea id="ocrResultsText" style="min-height: 150px;" placeholder="Extracted text will appear here..."></textarea>
        <div style="margin-top: 10px; font-size: 12px; color: #999;">
            <span id="ocrWordCount"></span>
        </div>

        <!-- Style Controls -->
        <div style="margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 8px;">
            <h4 style="margin: 0 0 12px 0; font-size: 14px; color: #333;">Overlay Style</h4>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <!-- Font Size -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        Font Size: <span id="ocrFontSizeValue">14</span>px
                    </label>
                    <input type="range" id="ocrFontSize" min="8" max="48" value="14"
                           style="width: 100%;" oninput="document.getElementById('ocrFontSizeValue').textContent = this.value">
                </div>

                <!-- Text Color -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        Text Color
                    </label>
                    <input type="color" id="ocrTextColor" value="#000000"
                           style="width: 100%; height: 32px; border: 1px solid #ddd; border-radius: 4px;">
                </div>

                <!-- Background Color -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        Background Color
                    </label>
                    <input type="color" id="ocrBgColor" value="#ffffff"
                           style="width: 100%; height: 32px; border: 1px solid #ddd; border-radius: 4px;">
                </div>

                <!-- Background Opacity -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        BG Opacity: <span id="ocrBgOpacityValue">90</span>%
                    </label>
                    <input type="range" id="ocrBgOpacity" min="0" max="100" value="90"
                           style="width: 100%;" oninput="document.getElementById('ocrBgOpacityValue').textContent = this.value">
                </div>

                <!-- Text Opacity -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        Text Opacity: <span id="ocrTextOpacityValue">100</span>%
                    </label>
                    <input type="range" id="ocrTextOpacity" min="0" max="100" value="100"
                           style="width: 100%;" oninput="document.getElementById('ocrTextOpacityValue').textContent = this.value">
                </div>

                <!-- Font Family -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        Font Family
                    </label>
                    <select id="ocrFontFamily" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="'Courier New', monospace">Courier New</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                        <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                        <option value="Impact, sans-serif">Impact</option>
                        <option value="'Lucida Console', monospace">Lucida Console</option>
                        <option value="Tahoma, sans-serif">Tahoma</option>
                    </select>
                </div>

                <!-- Text Alignment -->
                <div style="grid-column: span 2;">
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                        Text Alignment
                    </label>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" class="align-btn active" data-align="left"
                                style="flex: 1; padding: 8px; background: #fff; border: 2px solid #2196F3; border-radius: 4px; cursor: pointer;"
                                onclick="setOCRAlign('left')">
                            ⬅ Left
                        </button>
                        <button type="button" class="align-btn" data-align="center"
                                style="flex: 1; padding: 8px; background: #fff; border: 2px solid #ddd; border-radius: 4px; cursor: pointer;"
                                onclick="setOCRAlign('center')">
                            ↔ Center
                        </button>
                        <button type="button" class="align-btn" data-align="right"
                                style="flex: 1; padding: 8px; background: #fff; border: 2px solid #ddd; border-radius: 4px; cursor: pointer;"
                                onclick="setOCRAlign('right')">
                            ➡ Right
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="edit-modal-actions" style="margin-top: 15px;">
            <button class="edit-modal-btn secondary" onclick="closeOCRModal()">Close</button>
            <button class="edit-modal-btn" onclick="copyOCRText()" style="background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white; display: inline-flex; align-items: center; gap: 8px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                    <rect x="9" y="9" width="13" height="13" rx="2" stroke="white" stroke-width="2"/>
                    <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" stroke="white" stroke-width="2"/>
                </svg>
                Copy Text
            </button>
            <button class="edit-modal-btn primary" onclick="insertOCRAsText()" style="display: inline-flex; align-items: center; gap: 8px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                    <path d="M12 5v14M5 12h14" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
                    <circle cx="12" cy="12" r="2" fill="white"/>
                </svg>
                Insert as Overlay
            </button>
        </div>
    </div>

    <!-- Extract Text Button (appears when selection is active with Select Text tool) -->
    <button id="extractOCRBtn" style="display: none; position: fixed; bottom: 30px; right: 30px; z-index: 1000;
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            color: white; border: none; padding: 16px 32px; border-radius: 16px;
            font-size: 16px; font-weight: 600; cursor: pointer;
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.35);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            align-items: center; gap: 10px;"
            onclick="extractTextFromSelection()"
            onmouseenter="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 12px 35px rgba(76, 175, 80, 0.45)'"
            onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 25px rgba(76, 175, 80, 0.35)'">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M10 13l2 2 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span>Extract Text</span>
    </button>

    <div class="loading" id="loading" style="display: none;">
        <div class="loading-content">
            <div class="spinner"></div>
            <div>Processing PDF...</div>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="customAlertModal" class="custom-modal" style="display: none;">
        <div class="custom-modal-content alert-modal">
            <div class="modal-icon" id="alertIcon">
                <!-- Icon will be inserted dynamically -->
            </div>
            <div class="modal-message" id="alertMessage"></div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" onclick="closeCustomAlert()">OK</button>
            </div>
        </div>
    </div>

    <!-- Custom Confirm Modal -->
    <div id="customConfirmModal" class="custom-modal" style="display: none;">
        <div class="custom-modal-content confirm-modal">
            <div class="modal-icon" id="confirmIcon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none">
                    <circle cx="12" cy="12" r="10" stroke="#FF9800" stroke-width="2"/>
                    <path d="M12 8v4M12 16h.01" stroke="#FF9800" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </div>
            <div class="modal-message" id="confirmMessage"></div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" onclick="closeCustomConfirm(false)">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="closeCustomConfirm(true)">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Signature Modal -->
    <div id="signatureModal" class="custom-modal" style="display: none;">
        <div class="signature-modal-content">
            <div class="signature-modal-header">
                <h2>
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                        <path d="M3 17l2.5-2.5M6 10l4-4 4 4-4 4-4-4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M14 14l4.5 4.5M18.5 18.5L21 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M3 21h4.5" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/>
                    </svg>
                    Add Signature
                </h2>
            </div>

            <div class="signature-tabs">
                <button class="signature-tab active" data-tab="draw" onclick="switchSignatureTab('draw')">Draw</button>
                <button class="signature-tab" data-tab="type" onclick="switchSignatureTab('type')">Type</button>
                <button class="signature-tab" data-tab="upload" onclick="switchSignatureTab('upload')">Upload</button>
            </div>

            <!-- Draw Tab -->
            <div id="signatureTab-draw" class="signature-tab-content active">
                <div class="signature-canvas-container">
                    <canvas id="signatureCanvas" width="540" height="200"></canvas>
                </div>
                <div class="signature-canvas-controls">
                    <button class="modal-btn modal-btn-secondary" onclick="clearSignatureCanvas()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        Clear
                    </button>
                    <span style="color: #666; font-size: 14px;">Sign above with your mouse or touchscreen</span>
                </div>
                <div class="signature-background-option" style="margin-top: 15px; padding: 10px; background: #f8f8f8; border-radius: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #333;">
                        <input type="checkbox" id="signatureTransparentBg" checked style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span>Transparent Background</span>
                    </label>
                    <p style="margin: 8px 0 0 26px; font-size: 12px; color: #666;">Uncheck to add a white background to your signature</p>
                </div>
            </div>

            <!-- Type Tab -->
            <div id="signatureTab-type" class="signature-tab-content">
                <input type="text" id="typeSignatureInput" class="type-signature-input" placeholder="Type your name..." maxlength="50">

                <div class="signature-color-picker">
                    <label>Signature Color:</label>
                    <input type="color" id="typeSignatureColor" value="#000000">
                </div>

                <div class="font-selector">
                    <div class="font-option selected" data-font="Dancing Script" style="font-family: 'Dancing Script', cursive;" onclick="selectSignatureFont(this, 'Dancing Script')">
                        <span id="typePreview1">Signature</span>
                    </div>
                    <div class="font-option" data-font="Great Vibes" style="font-family: 'Great Vibes', cursive;" onclick="selectSignatureFont(this, 'Great Vibes')">
                        <span id="typePreview2">Signature</span>
                    </div>
                    <div class="font-option" data-font="Pacifico" style="font-family: 'Pacifico', cursive;" onclick="selectSignatureFont(this, 'Pacifico')">
                        <span id="typePreview3">Signature</span>
                    </div>
                    <div class="font-option" data-font="Sacramento" style="font-family: 'Sacramento', cursive;" onclick="selectSignatureFont(this, 'Sacramento')">
                        <span id="typePreview4">Signature</span>
                    </div>
                </div>
            </div>

            <!-- Upload Tab -->
            <div id="signatureTab-upload" class="signature-tab-content">
                <div class="upload-area" id="signatureUploadArea" onclick="document.getElementById('signatureFileInput').click()">
                    <div class="upload-icon">📄</div>
                    <div class="upload-text">Click to upload or drag & drop</div>
                    <div class="upload-hint">PNG or JPG • Max 5MB • Background will be removed</div>
                </div>
                <input type="file" id="signatureFileInput" accept="image/png,image/jpeg" onchange="handleSignatureUpload(event)">

                <div id="signaturePreviewContainer" class="signature-preview-container">
                    <img id="signaturePreviewImg" class="signature-preview" alt="Signature preview">
                </div>
            </div>

            <div class="signature-modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeSignatureModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="applySignature()">Apply Signature</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Global variables
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let currentTool = 'editText';
        let isDrawing = false;
        let annotations = [];
        let textEdits = [];  // Store edited text
        let currentAnnotation = null;
        let pdfBytes = null;
        let currentEditingTextItem = null;
        let textItems = [];  // Store text items for editing

        // Drag state for text repositioning
        let isDraggingText = false;
        let draggedTextElement = null;
        let draggedOverlayElement = null;
        let dragOffset = { x: 0, y: 0 };

        // OCR state
        let ocrCache = new Map(); // Cache OCR results per page
        let ocrWorker = null; // Tesseract worker instance

        // OCR selection state
        let ocrSelection = null; // Current OCR selection rectangle {x, y, width, height}
        let isSelectingOCR = false; // Currently drawing selection
        let ocrSelectionStart = null; // Starting point of selection
        let ocrExtractions = []; // Array of {rect, text, page} for multiple extractions

        // Text overlays (smart positioned OCR text)
        let textOverlays = []; // Array of {id, text, x, y, width, height, fontSize, color, bgColor, alignment, page}
        let selectedOverlay = null; // Currently selected overlay for editing
        let currentOCRAlignment = 'left'; // Current text alignment for OCR overlays

        // PDF text detection
        let isImageOnlyPDF = false; // Track if PDF has no text layer

        const pdfCanvas = document.getElementById('pdfCanvas');
        const annCanvas = document.getElementById('annotationCanvas');
        const textLayer = document.getElementById('textLayer');
        const pdfCtx = pdfCanvas.getContext('2d');
        const annCtx = annCanvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');

        // Custom Modal Functions
        let confirmCallback = null; // Store callback for confirm modal

        function showAlert(message, type = 'info') {
            const modal = document.getElementById('customAlertModal');
            const messageEl = document.getElementById('alertMessage');
            const iconEl = document.getElementById('alertIcon');

            messageEl.textContent = message;

            // Set icon based on type
            let iconSVG = '';
            if (type === 'error') {
                iconSVG = `
                    <svg width="56" height="56" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="10" stroke="#DC1F26" stroke-width="2" fill="#FFF0F0"/>
                        <path d="M15 9l-6 6M9 9l6 6" stroke="#DC1F26" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                `;
            } else if (type === 'success') {
                iconSVG = `
                    <svg width="56" height="56" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="10" stroke="#4CAF50" stroke-width="2" fill="#F0FFF4"/>
                        <path d="M9 12l2 2 4-4" stroke="#4CAF50" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                `;
            } else if (type === 'warning') {
                iconSVG = `
                    <svg width="56" height="56" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="10" stroke="#FF9800" stroke-width="2" fill="#FFF8E1"/>
                        <path d="M12 8v4M12 16h.01" stroke="#FF9800" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                `;
            } else {
                // info
                iconSVG = `
                    <svg width="56" height="56" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="10" stroke="#2196F3" stroke-width="2" fill="#E3F2FD"/>
                        <path d="M12 16v-4M12 8h.01" stroke="#2196F3" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                `;
            }

            iconEl.innerHTML = iconSVG;
            modal.style.display = 'flex';
        }

        function closeCustomAlert() {
            const modal = document.getElementById('customAlertModal');
            modal.style.display = 'none';
        }

        function showConfirm(message, callback) {
            const modal = document.getElementById('customConfirmModal');
            const messageEl = document.getElementById('confirmMessage');

            messageEl.textContent = message;
            confirmCallback = callback;
            modal.style.display = 'flex';
        }

        function closeCustomConfirm(result) {
            const modal = document.getElementById('customConfirmModal');
            modal.style.display = 'none';

            if (confirmCallback) {
                confirmCallback(result);
                confirmCallback = null;
            }
        }

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Check and close all modals in priority order
                const alertModal = document.getElementById('customAlertModal');
                const confirmModal = document.getElementById('customConfirmModal');
                const signatureModal = document.getElementById('signatureModal');
                const editModal = document.getElementById('editModal');
                const ocrModal = document.getElementById('ocrResultsModal');

                // Close alert modal
                if (alertModal && alertModal.style.display === 'flex') {
                    closeCustomAlert();
                    return;
                }

                // Close confirm modal
                if (confirmModal && confirmModal.style.display === 'flex') {
                    closeCustomConfirm(false);
                    return;
                }

                // Close signature modal
                if (signatureModal && signatureModal.style.display !== 'none') {
                    closeSignatureModal();
                    return;
                }

                // Close edit text modal
                if (editModal && editModal.style.display !== 'none' && editModal.style.display !== '') {
                    closeEditModal();
                    return;
                }

                // Close OCR results modal
                if (ocrModal && ocrModal.classList.contains('active')) {
                    closeOCRModal();
                    return;
                }
            }
        });

        // ========== SIGNATURE MODAL FUNCTIONS ==========

        // Signature state
        let signaturePad = null;
        let currentSignatureImage = null; // Stores the signature as data URL
        let selectedSignatureFont = 'Dancing Script';
        let signatures = []; // Array to store placed signatures
        let actionHistory = []; // Track all actions (annotations and signatures) in chronological order
        let removedAreas = []; // Array to store areas to be removed/covered: {x, y, width, height, page}
        let selectedSignature = null; // Track currently selected signature for deletion

        // Initialize Signature Pad when modal opens
        function initializeSignaturePad() {
            const canvas = document.getElementById('signatureCanvas');
            if (!signaturePad && canvas) {
                signaturePad = new SignaturePad(canvas, {
                    backgroundColor: 'rgba(0, 0, 0, 0)', // Transparent background
                    penColor: 'rgb(0, 0, 0)',
                    minWidth: 1,
                    maxWidth: 2.5
                });
            }
        }

        // Open signature modal
        function openSignatureModal() {
            document.getElementById('signatureModal').style.display = 'flex';

            // Initialize signature pad for draw tab
            if (!signaturePad) {
                setTimeout(() => initializeSignaturePad(), 100);
            }

            // Reset to draw tab
            switchSignatureTab('draw');
        }

        // Close signature modal
        function closeSignatureModal() {
            document.getElementById('signatureModal').style.display = 'none';

            // Clear all tabs
            if (signaturePad) {
                signaturePad.clear();
            }
            document.getElementById('typeSignatureInput').value = '';
            document.getElementById('signatureFileInput').value = '';
            document.getElementById('signaturePreviewContainer').style.display = 'none';
            currentSignatureImage = null;
        }

        // Switch between signature tabs
        function switchSignatureTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.signature-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.signature-tab[data-tab="${tabName}"]`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.signature-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`signatureTab-${tabName}`).classList.add('active');

            // Initialize signature pad if switching to draw tab
            if (tabName === 'draw' && !signaturePad) {
                setTimeout(() => initializeSignaturePad(), 100);
            }
        }

        // Clear signature canvas
        function clearSignatureCanvas() {
            if (signaturePad) {
                signaturePad.clear();
            }
        }

        // Select font for typed signature
        function selectSignatureFont(element, fontName) {
            document.querySelectorAll('.font-option').forEach(option => {
                option.classList.remove('selected');
            });
            element.classList.add('selected');
            selectedSignatureFont = fontName;

            // Update preview with typed text if any
            updateTypedSignaturePreview();
        }

        // Update typed signature preview
        function updateTypedSignaturePreview() {
            const text = document.getElementById('typeSignatureInput').value || 'Signature';
            document.querySelectorAll('.font-option span').forEach((span, index) => {
                span.textContent = text;
            });
        }

        // Listen for typing in signature input
        document.addEventListener('DOMContentLoaded', () => {
            const typeInput = document.getElementById('typeSignatureInput');
            if (typeInput) {
                typeInput.addEventListener('input', updateTypedSignaturePreview);
            }
        });

        // Handle signature file upload
        async function handleSignatureUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                showAlert('File size exceeds 5MB limit', 'error');
                return;
            }

            // Validate file type
            if (!file.type.match('image/(png|jpeg)')) {
                showAlert('Please upload a PNG or JPG image', 'error');
                return;
            }

            // Read and process the image
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const img = new Image();
                    img.onload = async function() {
                        // Remove background and show preview
                        const processedDataURL = await removeBackgroundFromImage(img);

                        // Show preview
                        document.getElementById('signaturePreviewImg').src = processedDataURL;
                        document.getElementById('signaturePreviewContainer').style.display = 'block';

                        // Store for later use
                        currentSignatureImage = processedDataURL;
                    };
                    img.src = e.target.result;
                } catch (error) {
                    showAlert('Failed to process image: ' + error.message, 'error');
                }
            };
            reader.readAsDataURL(file);
        }

        // Smart background removal using adaptive color detection
        async function removeBackgroundFromImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width;
            canvas.height = img.height;

            // Draw image
            ctx.drawImage(img, 0, 0);

            // Get image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Step 1: Detect background color by sampling edges
            const bgColor = detectBackgroundColor(data, canvas.width, canvas.height);

            // Step 2: Remove pixels similar to background color
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Calculate color distance from background
                const colorDistance = Math.sqrt(
                    Math.pow(r - bgColor.r, 2) +
                    Math.pow(g - bgColor.g, 2) +
                    Math.pow(b - bgColor.b, 2)
                );

                // If pixel is similar to background, make it transparent
                if (colorDistance < 60) {
                    data[i + 3] = 0; // Fully transparent
                } else if (colorDistance < 90) {
                    // Gradual fade for edge smoothing
                    const alpha = ((colorDistance - 60) / 30) * 255;
                    data[i + 3] = Math.min(data[i + 3], alpha);
                }
            }

            // Put modified image data back
            ctx.putImageData(imageData, 0, 0);

            return canvas.toDataURL('image/png');
        }

        // Detect background color by sampling edges and corners
        function detectBackgroundColor(data, width, height) {
            const samples = [];
            const sampleSize = 5; // Sample 5 pixels from each edge

            // Sample top edge
            for (let x = 0; x < width; x += Math.floor(width / sampleSize)) {
                const i = (0 * width + x) * 4;
                samples.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
            }

            // Sample bottom edge
            for (let x = 0; x < width; x += Math.floor(width / sampleSize)) {
                const i = ((height - 1) * width + x) * 4;
                samples.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
            }

            // Sample left edge
            for (let y = 0; y < height; y += Math.floor(height / sampleSize)) {
                const i = (y * width + 0) * 4;
                samples.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
            }

            // Sample right edge
            for (let y = 0; y < height; y += Math.floor(height / sampleSize)) {
                const i = (y * width + (width - 1)) * 4;
                samples.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
            }

            // Calculate average background color
            const avgR = samples.reduce((sum, s) => sum + s.r, 0) / samples.length;
            const avgG = samples.reduce((sum, s) => sum + s.g, 0) / samples.length;
            const avgB = samples.reduce((sum, s) => sum + s.b, 0) / samples.length;

            return { r: avgR, g: avgG, b: avgB };
        }

        // Drag and drop for signature upload
        const uploadArea = document.getElementById('signatureUploadArea');
        if (uploadArea) {
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('drag-over');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('drag-over');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    document.getElementById('signatureFileInput').files = files;
                    handleSignatureUpload({ target: { files: files } });
                }
            });
        }

        // Add white background to signature image
        function addWhiteBackgroundToSignature(dataURL) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // Create a new canvas with white background
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = img.width;
                    canvas.height = img.height;

                    // Fill with white background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw signature on top
                    ctx.drawImage(img, 0, 0);

                    resolve(canvas.toDataURL('image/png'));
                };
                img.src = dataURL;
            });
        }

        // Apply signature to PDF
        async function applySignature() {
            let signatureDataURL = null;

            // Get signature based on active tab
            const activeTab = document.querySelector('.signature-tab.active').dataset.tab;

            if (activeTab === 'draw') {
                if (!signaturePad || signaturePad.isEmpty()) {
                    showAlert('Please draw your signature first', 'warning');
                    return;
                }
                signatureDataURL = signaturePad.toDataURL('image/png');
            } else if (activeTab === 'type') {
                const typedText = document.getElementById('typeSignatureInput').value.trim();
                if (!typedText) {
                    showAlert('Please type your signature first', 'warning');
                    return;
                }

                // Create canvas with typed signature
                signatureDataURL = await createTypedSignature(typedText);
            } else if (activeTab === 'upload') {
                if (!currentSignatureImage) {
                    showAlert('Please upload a signature image first', 'warning');
                    return;
                }
                signatureDataURL = currentSignatureImage;
            }

            // Apply white background if option is unchecked (for draw tab)
            if (activeTab === 'draw') {
                const transparentBg = document.getElementById('signatureTransparentBg');
                if (transparentBg && !transparentBg.checked) {
                    signatureDataURL = await addWhiteBackgroundToSignature(signatureDataURL);
                }
            }

            // Close modal
            closeSignatureModal();

            // Add signature as an image overlay to the PDF
            addSignatureToPage(signatureDataURL);
        }

        // Create typed signature as canvas image
        async function createTypedSignature(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 600;
            canvas.height = 150;

            // Set font
            const color = document.getElementById('typeSignatureColor').value;
            ctx.font = `64px '${selectedSignatureFont}', cursive`;
            ctx.fillStyle = color;
            ctx.textBaseline = 'middle';

            // Measure text
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;

            // Center text
            const x = (canvas.width - textWidth) / 2;
            const y = canvas.height / 2;

            // Draw text
            ctx.fillText(text, x, y);

            return canvas.toDataURL('image/png');
        }

        // Add signature to the current page
        function addSignatureToPage(signatureDataURL) {
            const img = new Image();
            img.onload = function() {
                // Create a signature object
                const signature = {
                    id: 'signature-' + Date.now(),
                    image: signatureDataURL,
                    x: 100, // Initial position
                    y: 100,
                    width: 200, // Initial width
                    height: (img.height / img.width) * 200, // Maintain aspect ratio
                    page: currentPage
                };

                signatures.push(signature);

                // Add to action history for undo support
                actionHistory.push({
                    type: 'signature',
                    data: signature
                });

                renderSignatures();

                showAlert('Signature added! You can drag to reposition it.', 'success');
            };
            img.src = signatureDataURL;
        }

        // Render all signatures on overlay layer
        function renderSignatures() {
            const overlayLayer = document.getElementById('overlayLayer');

            // Clear existing signatures for current page
            overlayLayer.querySelectorAll('.signature-overlay').forEach(el => el.remove());

            // Render signatures for current page
            signatures.filter(sig => sig.page === currentPage).forEach(signature => {
                const sigElement = document.createElement('div');
                sigElement.className = 'signature-overlay';
                sigElement.style.position = 'absolute';
                sigElement.style.left = signature.x + 'px';
                sigElement.style.top = signature.y + 'px';
                sigElement.style.width = signature.width + 'px';
                sigElement.style.height = signature.height + 'px';
                sigElement.style.cursor = 'move';
                // Highlight if selected
                if (selectedSignature === signature) {
                    sigElement.style.border = '2px solid #DC1F26';
                    sigElement.style.boxShadow = '0 0 10px rgba(220, 31, 38, 0.5)';
                } else {
                    sigElement.style.border = '2px dashed rgba(220, 31, 38, 0.5)';
                }
                sigElement.style.boxSizing = 'border-box';
                sigElement.dataset.signatureId = signature.id;

                // Add click handler for selection
                sigElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedSignature = signature;
                    renderSignatures(); // Re-render to show selection
                });

                const img = document.createElement('img');
                img.src = signature.image;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.pointerEvents = 'none';

                sigElement.appendChild(img);

                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'signature-resize-handle';
                resizeHandle.style.position = 'absolute';
                resizeHandle.style.right = '-5px';
                resizeHandle.style.bottom = '-5px';
                resizeHandle.style.width = '12px';
                resizeHandle.style.height = '12px';
                resizeHandle.style.backgroundColor = '#DC1F26';
                resizeHandle.style.border = '2px solid #FFFFFF';
                resizeHandle.style.borderRadius = '50%';
                resizeHandle.style.cursor = 'nwse-resize';
                resizeHandle.style.zIndex = '10';
                resizeHandle.style.boxShadow = '0 0 4px rgba(0,0,0,0.3)';
                sigElement.appendChild(resizeHandle);

                overlayLayer.appendChild(sigElement);

                // Make signature draggable and resizable
                makeSignatureDraggable(sigElement, signature);
                makeSignatureResizable(resizeHandle, sigElement, signature);
            });
        }

        // Make signature draggable
        function makeSignatureDraggable(element, signature) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            element.addEventListener('mousedown', (e) => {
                if (currentTool !== 'editText' && currentTool !== 'moveText') return;

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = signature.x;
                initialY = signature.y;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                signature.x = initialX + dx;
                signature.y = initialY + dy;

                element.style.left = signature.x + 'px';
                element.style.top = signature.y + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Make signature resizable
        function makeSignatureResizable(resizeHandle, element, signature) {
            let isResizing = false;
            let startX, startY, startWidth, startHeight;
            const aspectRatio = signature.height / signature.width;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = signature.width;
                startHeight = signature.height;
                e.stopPropagation(); // Prevent dragging when resizing
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const dx = e.clientX - startX;

                // Calculate new width based on mouse movement
                let newWidth = startWidth + dx;

                // Minimum size constraint
                if (newWidth < 50) newWidth = 50;

                // Maximum size constraint (don't exceed canvas bounds)
                const maxWidth = pdfCanvas.width - signature.x - 20;
                if (newWidth > maxWidth) newWidth = maxWidth;

                // Calculate new height maintaining aspect ratio
                let newHeight = newWidth * aspectRatio;

                // Update signature dimensions
                signature.width = newWidth;
                signature.height = newHeight;

                // Update element styles
                element.style.width = newWidth + 'px';
                element.style.height = newHeight + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                }
            });
        }

        // Delete selected signature
        function deleteSelectedSignature() {
            if (!selectedSignature) return;

            // Find the signature in the array
            const index = signatures.findIndex(sig => sig === selectedSignature);
            if (index !== -1) {
                // Remove from signatures array
                signatures.splice(index, 1);

                // Remove from action history
                const historyIndex = actionHistory.findIndex(action =>
                    action.type === 'signature' && action.data === selectedSignature
                );
                if (historyIndex !== -1) {
                    actionHistory.splice(historyIndex, 1);
                }

                // Clear selection
                selectedSignature = null;

                // Re-render signatures
                renderSignatures();

                showAlert('Signature deleted', 'success');
            }
        }

        // Deselect signature when clicking outside
        document.addEventListener('click', (e) => {
            // If click is not on a signature element, deselect
            if (!e.target.closest('.signature-overlay') && selectedSignature) {
                selectedSignature = null;
                renderSignatures();
            }
        });

        // Load PDF from sessionStorage
        window.addEventListener('load', async () => {
            const pdfData = sessionStorage.getItem('pdfToEdit');
            const fileName = sessionStorage.getItem('pdfFileName');

            if (!pdfData) {
                showAlert('No PDF file found. Redirecting to home...', 'error');
                setTimeout(() => {
                    window.location.href = '/';
                }, 2000);
                return;
            }

            document.getElementById('docName').value = fileName || 'Edited PDF';

            // Show loading
            document.getElementById('loading').style.display = 'flex';

            try {
                console.log('PDF data from sessionStorage length:', pdfData.length);
                console.log('PDF data starts with:', pdfData.substring(0, 50));

                // Convert data URL to Uint8Array
                const base64Data = pdfData.split(',')[1];
                if (!base64Data) {
                    throw new Error('Invalid PDF data format - missing base64 data');
                }

                console.log('Base64 data length:', base64Data.length);

                pdfBytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));

                console.log('✓ pdfBytes created successfully');
                console.log('  - Length:', pdfBytes.length);
                console.log('  - First bytes:', Array.from(pdfBytes.slice(0, 10)));
                console.log('  - Type:', pdfBytes.constructor.name);

                // IMPORTANT: Create a copy for PDF.js to prevent buffer detachment
                // PDF.js may transfer ownership of the ArrayBuffer, which would empty pdfBytes
                const pdfBytesCopy = new Uint8Array(pdfBytes);

                // Load PDF with PDF.js using the copy
                const loadingTask = pdfjsLib.getDocument({ data: pdfBytesCopy });
                pdfDoc = await loadingTask.promise;
                totalPages = pdfDoc.numPages;

                console.log('✓ PDF loaded successfully with', totalPages, 'pages');

                document.getElementById('totalPages').textContent = totalPages;

                // Render first page
                await renderPage(1);

                // Load test overlay if present
                const testOverlayData = sessionStorage.getItem('testOverlay');
                if (testOverlayData) {
                    try {
                        const testOverlay = JSON.parse(testOverlayData);
                        textOverlays.push(testOverlay);
                        renderTextOverlays();
                        console.log('✓ Test overlay loaded:', testOverlay);
                        // Clear it so it doesn't load again on refresh
                        sessionStorage.removeItem('testOverlay');
                    } catch (error) {
                        console.error('Error loading test overlay:', error);
                    }
                }

                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('❌ Error loading PDF:', error);
                console.error('pdfBytes status:', pdfBytes ? `Length: ${pdfBytes.length}` : 'null/undefined');
                showAlert('Failed to load PDF: ' + error.message, 'error');
                document.getElementById('loading').style.display = 'none';
            }
        });

        // Initialize Tesseract OCR worker
        async function initOCRWorker() {
            if (!ocrWorker) {
                console.log('Initializing OCR worker...');
                ocrWorker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            console.log(`OCR Progress: ${Math.round(m.progress * 100)}%`);
                        } else {
                            console.log('OCR:', m.status);
                        }
                    }
                });
                console.log('✓ OCR worker initialized');
            }
            return ocrWorker;
        }

        // Run OCR on current PDF page
        async function runOCROnPage(page, viewport) {
            const pageKey = `page-${currentPage}`;

            // Check cache first
            if (ocrCache.has(pageKey)) {
                console.log('Using cached OCR results for page', currentPage);
                return ocrCache.get(pageKey);
            }

            console.log('Running OCR on page', currentPage, '...');

            // Show OCR progress
            const loadingDiv = document.getElementById('loading');
            const loadingText = loadingDiv.querySelector('div:last-child');
            const originalText = loadingText.textContent;
            loadingDiv.style.display = 'flex';
            loadingText.textContent = 'Extracting text from PDF...';

            try {
                // Create a temporary canvas for OCR
                const ocrCanvas = document.createElement('canvas');
                ocrCanvas.width = viewport.width;
                ocrCanvas.height = viewport.height;
                const ocrCtx = ocrCanvas.getContext('2d');

                // Render page to canvas at higher resolution for better OCR
                const ocrViewport = page.getViewport({ scale: 2.0 });
                ocrCanvas.width = ocrViewport.width;
                ocrCanvas.height = ocrViewport.height;

                await page.render({
                    canvasContext: ocrCtx,
                    viewport: ocrViewport
                }).promise;

                // Initialize OCR worker
                const worker = await initOCRWorker();

                // Run OCR
                const { data } = await worker.recognize(ocrCanvas);

                console.log(`✓ OCR completed: found ${data.words.length} words`);

                // Convert OCR results to text items format
                // Scale coordinates back to match viewport scale (1.5x)
                const scale = 1.5 / 2.0; // from 2.0x (OCR) to 1.5x (display)

                const ocrTextItems = data.words.map((word, index) => {
                    const bbox = word.bbox;
                    return {
                        str: word.text,
                        transform: [
                            1, 0, 0, 1,
                            bbox.x0 * scale,  // x position
                            (ocrViewport.height - bbox.y1) * scale  // y position (PDF coords are bottom-up)
                        ],
                        width: (bbox.x1 - bbox.x0) * scale,
                        height: (bbox.y1 - bbox.y0) * scale,
                        fontName: 'sans-serif', // Default font for OCR text
                        hasEOL: false,
                        isOCR: true // Mark as OCR-generated
                    };
                });

                // Cache the results
                ocrCache.set(pageKey, ocrTextItems);

                loadingDiv.style.display = 'none';
                loadingText.textContent = originalText;

                return ocrTextItems;

            } catch (error) {
                console.error('OCR error:', error);
                loadingDiv.style.display = 'none';
                loadingText.textContent = originalText;

                showAlert('OCR failed: ' + error.message + '\n\nThe PDF may not contain recognizable text.', 'error');
                return [];
            }
        }

        // Filter out overlapping duplicate text items (common in PDFs created by certain tools)
        function filterOverlappingText(items, viewport) {
            if (items.length === 0) return items;

            const filtered = [];
            const Y_THRESHOLD = 10; // pixels - for detecting items on the same line

            // Convert items to a more usable format with positions
            const processedItems = items.map((item, index) => {
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                return {
                    original: item,
                    text: item.str,
                    x: tx[4],
                    y: tx[5],
                    index: index,
                    skip: false
                };
            });

            // Check for overlapping items
            for (let i = 0; i < processedItems.length; i++) {
                if (processedItems[i].skip) continue;

                for (let j = i + 1; j < processedItems.length; j++) {
                    if (processedItems[j].skip) continue;

                    const item1 = processedItems[i];
                    const item2 = processedItems[j];

                    // Check if items are on the same line (similar Y position)
                    const yDiff = Math.abs(item1.y - item2.y);

                    // If on same line, check if one text contains the other
                    if (yDiff <= Y_THRESHOLD) {
                        const text1 = item1.text.trim();
                        const text2 = item2.text.trim();

                        // Skip empty strings
                        if (text1.length === 0 || text2.length === 0) {
                            if (text1.length === 0) {
                                processedItems[i].skip = true;
                                console.log(`Filtering empty text at index ${i}`);
                                break;
                            } else if (text2.length === 0) {
                                processedItems[j].skip = true;
                                console.log(`Filtering empty text at index ${j}`);
                                continue;
                            }
                        }

                        // Check if one text contains the other (substring relationship)
                        if (text1.includes(text2) && text1.length > text2.length) {
                            // text1 is longer and contains text2, skip text2
                            processedItems[j].skip = true;
                            console.log(`Filtering duplicate: "${text2}" (contained in "${text1}") at positions (${item1.x}, ${item1.y}) and (${item2.x}, ${item2.y})`);
                        } else if (text2.includes(text1) && text2.length > text1.length) {
                            // text2 is longer and contains text1, skip text1
                            processedItems[i].skip = true;
                            console.log(`Filtering duplicate: "${text1}" (contained in "${text2}") at positions (${item1.x}, ${item1.y}) and (${item2.x}, ${item2.y})`);
                            break; // Move to next i since this one is skipped
                        }
                    }
                }

                if (!processedItems[i].skip) {
                    filtered.push(processedItems[i].original);
                }
            }

            // Add any remaining items that weren't compared yet
            for (let i = 0; i < processedItems.length; i++) {
                if (!processedItems[i].skip && !filtered.includes(processedItems[i].original)) {
                    filtered.push(processedItems[i].original);
                }
            }

            const removedCount = items.length - filtered.length;
            if (removedCount > 0) {
                console.log(`Filtered out ${removedCount} overlapping text items`);
            }

            return filtered;
        }

        // Render PDF page with text layer
        async function renderPage(pageNumber) {
            currentPage = pageNumber;
            document.getElementById('currentPage').textContent = pageNumber;

            const page = await pdfDoc.getPage(pageNumber);
            const viewport = page.getViewport({ scale: 1.5 });

            // Set canvas dimensions
            pdfCanvas.width = viewport.width;
            pdfCanvas.height = viewport.height;
            annCanvas.width = viewport.width;
            annCanvas.height = viewport.height;

            // Render PDF page
            const renderContext = {
                canvasContext: pdfCtx,
                viewport: viewport
            };
            await page.render(renderContext).promise;

            // Render text layer
            const textContent = await page.getTextContent();
            textLayer.innerHTML = '';
            textLayer.style.width = viewport.width + 'px';
            textLayer.style.height = viewport.height + 'px';

            textItems = [];

            // Render text items from PDF (no automatic OCR)
            let itemsToRender = textContent.items;

            // Filter out overlapping duplicate text items (common in some PDFs)
            itemsToRender = filterOverlappingText(itemsToRender, viewport);

            if (itemsToRender.length === 0) {
                console.log('ℹ️  No text layer found in PDF. Use "Select Text" tool to extract text from specific areas.');

                // Detect image-only PDF on first page
                if (pageNumber === 1) {
                    isImageOnlyPDF = true;
                    updateToolsForImageOnlyPDF();
                }
            } else if (pageNumber === 1) {
                isImageOnlyPDF = false;
            }

            console.log(`Rendering ${itemsToRender.length} text items...`);

            // Debug: Log first few items to check for duplicates
            if (pageNumber === 1 && itemsToRender.length > 0) {
                console.log('First 3 text items:', itemsToRender.slice(0, 3).map(item => ({
                    text: item.str,
                    x: item.transform[4],
                    y: item.transform[5]
                })));
            }

            itemsToRender.forEach((item, index) => {
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                // For OCR items, use the height property directly; for PDF text, calculate from transform
                const fontHeight = item.isOCR ? item.height : Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
                const fontAscent = item.fontName ? fontHeight : fontHeight * 0.8;

                const textSpan = document.createElement('span');
                textSpan.textContent = item.str.trim(); // Remove leading/trailing whitespace
                // Compensate for font rendering and left-side bearing
                const leftAdjustment = fontHeight * 0.20; // 20% of font size for stronger correction
                textSpan.style.left = (tx[4] - leftAdjustment) + 'px';
                textSpan.style.top = (tx[5] - fontAscent) + 'px';
                textSpan.style.fontSize = fontHeight + 'px';
                textSpan.style.fontFamily = 'Helvetica, Arial, sans-serif';
                textSpan.style.marginLeft = '0';
                textSpan.style.paddingLeft = '0';
                textSpan.style.transform = 'translateX(-2px)'; // Additional pixel-perfect adjustment
                textSpan.style.textIndent = '0';
                textSpan.style.letterSpacing = 'normal';
                textSpan.dataset.index = index;
                textSpan.dataset.page = pageNumber;

                // Click handler for editing text
                textSpan.addEventListener('click', (e) => {
                    if (currentTool === 'editText') {
                        e.stopPropagation();
                        openEditModal(item, textSpan, pageNumber);
                    }
                });

                // Enable drag-and-drop for ALL text (not just edited)
                enableTextDragForAnyText(textSpan, item, pageNumber);

                textLayer.appendChild(textSpan);

                textItems.push({
                    text: item.str,
                    x: tx[4],
                    y: tx[5],
                    fontSize: fontHeight,
                    fontName: item.fontName,
                    span: textSpan,
                    page: pageNumber
                });
            });

            // Update text layer visibility based on tool
            updateTextLayerVisibility();

            // Re-apply text edits for current page
            reapplyTextEdits();

            // Re-render annotations
            redrawAnnotations();

            // Re-render text overlays
            renderTextOverlays();

            // Re-render signatures
            renderSignatures();

            // Update page buttons
            document.getElementById('prevPage').disabled = pageNumber === 1;
            document.getElementById('nextPage').disabled = pageNumber === totalPages;
        }

        // Re-apply text edits after page re-render
        function reapplyTextEdits() {
            const pageEdits = textEdits.filter(edit => edit.page === currentPage);

            if (pageEdits.length > 0) {
                console.log(`Re-applying ${pageEdits.length} text edits for page ${currentPage}`);
            }

            pageEdits.forEach(edit => {
                // Find the text span for this edit
                const textSpan = document.querySelector(
                    `#textLayer span[data-index="${edit.index}"][data-page="${edit.page}"]`
                );

                if (textSpan) {
                    // Remove any existing overlay first
                    const existingOverlay = document.querySelector(
                        `.text-edit-overlay[data-edit-index="${edit.index}"][data-edit-page="${edit.page}"]`
                    );
                    if (existingOverlay) {
                        existingOverlay.remove();
                    }

                    // Update text content
                    textSpan.textContent = edit.newText;

                    // Update position
                    textSpan.style.left = edit.x + 'px';
                    textSpan.style.top = edit.y + 'px';

                    // Mark as edited
                    textSpan.classList.add('edited');
                    textSpan.title = `Edited from: "${edit.originalText}"`;

                    // Create white overlay to cover original text
                    const overlay = document.createElement('div');
                    overlay.className = 'text-edit-overlay';
                    overlay.style.position = 'absolute';
                    overlay.style.left = (edit.originalX || edit.x) + 'px';
                    overlay.style.top = (edit.originalY || edit.y) + 'px';
                    overlay.style.width = edit.width + 'px';
                    overlay.style.height = textSpan.style.fontSize;
                    overlay.style.backgroundColor = 'white';
                    overlay.style.zIndex = '1';
                    overlay.dataset.editIndex = edit.index;
                    overlay.dataset.editPage = edit.page;

                    // Insert overlay before text span
                    textSpan.parentElement.insertBefore(overlay, textSpan);

                    // Style text span
                    textSpan.style.zIndex = '2';
                    textSpan.style.width = 'auto';
                    textSpan.style.display = 'inline-block';

                    // Re-enable dragging (already enabled by enableTextDragForAnyText in renderPage)
                }
            });
        }

        // Update tools for image-only PDF
        function updateToolsForImageOnlyPDF() {
            const editTextBtn = document.getElementById('editTextTool');
            const moveTextBtn = document.getElementById('moveTextTool');
            const addTextBtn = document.getElementById('addTextTool');
            const ocrSelectBtn = document.getElementById('ocrSelectTool');

            // Disable text editing tools
            editTextBtn.disabled = true;
            editTextBtn.style.opacity = '0.4';
            editTextBtn.style.cursor = 'not-allowed';
            editTextBtn.title = 'No text layer found - Use "Select Text" to extract text with OCR';

            moveTextBtn.disabled = true;
            moveTextBtn.style.opacity = '0.4';
            moveTextBtn.style.cursor = 'not-allowed';
            moveTextBtn.title = 'No text layer found - Use "Select Text" to extract text with OCR';

            // Keep Add Text enabled (users can still add new text overlays)
            // But update tooltip
            addTextBtn.title = 'Add new text overlay to the PDF';

            // Automatically select OCR tool and highlight it
            setTool('ocrSelect');

            // Add pulsing animation to OCR button to draw attention
            ocrSelectBtn.style.animation = 'pulse 2s ease-in-out 3';
            setTimeout(() => {
                ocrSelectBtn.style.animation = '';
            }, 6000);

            console.log('✓ Image-only PDF detected - Edit Text tool disabled, Select Text tool prioritized');
        }

        // Update text layer visibility
        function updateTextLayerVisibility() {
            if (currentTool === 'editText' || currentTool === 'moveText') {
                textLayer.classList.add('editable');
            } else {
                textLayer.classList.remove('editable');
            }
        }

        // Open edit modal
        function openEditModal(textItem, textSpan, pageNumber) {
            currentEditingTextItem = {
                original: textItem.str,
                span: textSpan,
                item: textItem,
                page: pageNumber
            };

            document.getElementById('originalText').textContent = textItem.str;
            document.getElementById('editTextArea').value = textItem.str;
            document.getElementById('editModal').style.display = 'flex';
            document.getElementById('editTextArea').focus();
            document.getElementById('editTextArea').select();
        }

        // Close edit modal
        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            currentEditingTextItem = null;
        }

        // Save text edit
        function saveTextEdit() {
            const newText = document.getElementById('editTextArea').value;

            if (!currentEditingTextItem) {
                console.error('No text item being edited');
                closeEditModal();
                return;
            }

            // Allow saving even if text is the same (user might want to dismiss)
            if (newText.trim() === '') {
                showAlert('Text cannot be empty. Use the ✕ button to remove an edit.', 'warning');
                return;
            }

            // Only update if text actually changed
            if (newText !== currentEditingTextItem.original) {
                const textSpan = currentEditingTextItem.span;
                const index = parseInt(textSpan.dataset.index);

                // Check if this text was already edited and update instead of adding
                const existingEditIndex = textEdits.findIndex(edit =>
                    edit.page === currentEditingTextItem.page && edit.index === index
                );

                // CRITICAL: Preserve original width when re-editing
                // First edit: capture current width (which is original text width)
                // Re-edit: reuse the stored width (don't capture the edited text width)
                const originalWidth = existingEditIndex >= 0
                    ? textEdits[existingEditIndex].width
                    : textSpan.offsetWidth;

                const currentX = parseFloat(textSpan.style.left);
                const currentY = parseFloat(textSpan.style.top);

                // Preserve originalX/originalY if this is a re-edit (text was already edited before)
                const originalX = existingEditIndex >= 0 && textEdits[existingEditIndex].originalX !== undefined
                    ? textEdits[existingEditIndex].originalX
                    : currentX;
                const originalY = existingEditIndex >= 0 && textEdits[existingEditIndex].originalY !== undefined
                    ? textEdits[existingEditIndex].originalY
                    : currentY;

                const editData = {
                    page: currentEditingTextItem.page,
                    index: index,
                    originalText: currentEditingTextItem.original,
                    newText: newText,
                    x: currentX,
                    y: currentY,
                    originalX: originalX,  // Store original position for white rectangle
                    originalY: originalY,  // Will stay constant when dragging
                    fontSize: parseFloat(textSpan.style.fontSize),
                    fontName: currentEditingTextItem.item.fontName,
                    width: originalWidth // Use preserved original width
                };

                if (existingEditIndex >= 0) {
                    // Save previous state for undo
                    const previousEdit = JSON.parse(JSON.stringify(textEdits[existingEditIndex]));

                    // Update existing edit
                    textEdits[existingEditIndex] = editData;

                    // Track update in action history
                    actionHistory.push({
                        type: 'textEditUpdate',
                        editIndex: existingEditIndex,
                        previousState: previousEdit,
                        currentState: JSON.parse(JSON.stringify(editData))
                    });
                } else {
                    // Add new edit
                    textEdits.push(editData);

                    // Track creation in action history
                    actionHistory.push({
                        type: 'textEditCreate',
                        edit: JSON.parse(JSON.stringify(editData))
                    });
                }

                // Update visual display
                textSpan.textContent = newText;
                textSpan.classList.add('edited');
                textSpan.title = `Edited from: "${currentEditingTextItem.original}"`;

                // Remove old overlay if this is a re-edit
                const oldOverlay = document.querySelector(
                    `.text-edit-overlay[data-edit-index="${index}"][data-edit-page="${currentEditingTextItem.page}"]`
                );
                if (oldOverlay) {
                    oldOverlay.remove();
                }

                // Create a white overlay to cover the original text in the PDF canvas
                // The text span itself will size naturally, but we need to cover the original text underneath
                const overlay = document.createElement('div');
                overlay.className = 'text-edit-overlay';
                overlay.style.position = 'absolute';
                overlay.style.left = textSpan.style.left;
                overlay.style.top = textSpan.style.top;
                overlay.style.width = originalWidth + 'px';
                overlay.style.height = textSpan.style.fontSize;
                overlay.style.backgroundColor = 'white';
                overlay.style.zIndex = '1';
                overlay.dataset.editIndex = index;
                overlay.dataset.editPage = currentEditingTextItem.page;

                // Insert overlay before the text span
                textSpan.parentElement.insertBefore(overlay, textSpan);

                // Make text span sit above the overlay
                // Keep position: absolute (from textLayer CSS) so text can move independently
                textSpan.style.zIndex = '2';
                textSpan.style.width = 'auto'; // Let text size naturally
                textSpan.style.display = 'inline-block';

                // Enable drag-and-drop for repositioning edited text
                enableTextDrag(textSpan, overlay);

                updateEditedTextList();

                console.log('Text edited successfully:', {
                    original: currentEditingTextItem.original,
                    new: newText,
                    originalWidth: originalWidth,
                    wasReEdit: existingEditIndex >= 0,
                    totalEdits: textEdits.length
                });

                // Show brief success message
                showNotification('Text updated successfully! ✓', 'success');
            } else {
                showNotification('No changes made', 'info');
            }

            closeEditModal();
        }

        // Show notification message
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : '#2196F3'};
                color: white;
                padding: 15px 25px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // Update edited text list in sidebar
        function updateEditedTextList() {
            const listDiv = document.getElementById('editedTextList');

            if (textEdits.length === 0) {
                listDiv.innerHTML = '<em>No text edited yet</em>';
                return;
            }

            listDiv.innerHTML = textEdits.map((edit, i) => `
                <div style="padding: 8px; background: #f9f9f9; margin-bottom: 5px; border-radius: 4px;">
                    <strong>Page ${edit.page}:</strong><br>
                    <span style="text-decoration: line-through; color: #999;">${edit.originalText.substring(0, 30)}${edit.originalText.length > 30 ? '...' : ''}</span><br>
                    <span style="color: #4CAF50;">→ ${edit.newText.substring(0, 30)}${edit.newText.length > 30 ? '...' : ''}</span>
                    <button onclick="removeEdit(${i})" style="float: right; background: none; border: none; color: #DC1F26; cursor: pointer;">✕</button>
                </div>
            `).join('');
        }

        // Remove a text edit
        function removeEdit(index) {
            const edit = textEdits[index];

            // Remove the overlay
            const overlay = document.querySelector(
                `.text-edit-overlay[data-edit-index="${edit.index}"][data-edit-page="${edit.page}"]`
            );
            if (overlay) {
                overlay.remove();
            }

            // Find and restore the text span
            const textSpan = Array.from(textLayer.children).find(span =>
                parseInt(span.dataset.index) === edit.index &&
                parseInt(span.dataset.page) === edit.page
            );

            if (textSpan) {
                textSpan.textContent = edit.originalText;
                textSpan.classList.remove('edited');
                textSpan.title = '';
                // Restore original span styling
                textSpan.style.width = '';
                textSpan.style.position = '';
                textSpan.style.zIndex = '';
                textSpan.style.display = '';
            }

            textEdits.splice(index, 1);
            updateEditedTextList();
        }

        // Enable drag-and-drop for edited text
        function enableTextDrag(textSpan, overlay) {
            let clickTimeout = null;
            let hasMoved = false;

            textSpan.addEventListener('mousedown', function(e) {
                // Only allow dragging in moveText mode
                if (currentTool !== 'moveText') return;

                // Don't start drag on double-click
                if (e.detail > 1) return;

                hasMoved = false;
                const startX = e.clientX;
                const startY = e.clientY;

                // Small delay to distinguish click from drag
                clickTimeout = setTimeout(() => {
                    isDraggingText = true;
                    draggedTextElement = textSpan;
                    draggedOverlayElement = overlay;

                    // Get current position
                    const rect = textSpan.getBoundingClientRect();
                    const layerRect = textLayer.getBoundingClientRect();

                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;

                    textSpan.classList.add('dragging');
                    e.preventDefault();
                }, 150);

                // Track if mouse moves before timeout
                const checkMove = (moveEvent) => {
                    const dx = Math.abs(moveEvent.clientX - startX);
                    const dy = Math.abs(moveEvent.clientY - startY);
                    if (dx > 5 || dy > 5) {
                        hasMoved = true;
                    }
                };

                document.addEventListener('mousemove', checkMove);

                // Clean up on mouseup
                const cleanupCheck = () => {
                    document.removeEventListener('mousemove', checkMove);
                    document.removeEventListener('mouseup', cleanupCheck);
                    if (!hasMoved && clickTimeout) {
                        clearTimeout(clickTimeout);
                    }
                };
                document.addEventListener('mouseup', cleanupCheck);
            });

            // Prevent click event from firing when we dragged
            textSpan.addEventListener('click', function(e) {
                if (hasMoved) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }, true);
        }

        // Handle text drag movement
        document.addEventListener('mousemove', function(e) {
            if (!isDraggingText || !draggedTextElement) return;

            e.preventDefault();

            const layerRect = textLayer.getBoundingClientRect();
            const newLeft = e.clientX - layerRect.left - dragOffset.x;
            const newTop = e.clientY - layerRect.top - dragOffset.y;

            // Update text position only (keep overlay at original position to cover original text)
            draggedTextElement.style.left = newLeft + 'px';
            draggedTextElement.style.top = newTop + 'px';

            // DO NOT move the overlay - it stays at the original position to keep covering the original PDF text
        });

        // Handle text drag end
        document.addEventListener('mouseup', function(e) {
            if (!isDraggingText || !draggedTextElement) return;

            draggedTextElement.classList.remove('dragging');

            // Update the textEdits array with new position
            const index = parseInt(draggedTextElement.dataset.index);
            const page = parseInt(draggedTextElement.dataset.page);

            const editIndex = textEdits.findIndex(edit =>
                edit.page === page && edit.index === index
            );

            if (editIndex >= 0) {
                // Save previous position for undo
                const previousX = textEdits[editIndex].x;
                const previousY = textEdits[editIndex].y;

                const newX = parseFloat(draggedTextElement.style.left);
                const newY = parseFloat(draggedTextElement.style.top);

                // Only track if position actually changed
                if (previousX !== newX || previousY !== newY) {
                    textEdits[editIndex].x = newX;
                    textEdits[editIndex].y = newY;

                    // Track move in action history
                    actionHistory.push({
                        type: 'textMove',
                        editIndex: editIndex,
                        previousX: previousX,
                        previousY: previousY,
                        newX: newX,
                        newY: newY
                    });

                    console.log('Text repositioned:', {
                        text: textEdits[editIndex].newText,
                        newX: newX,
                        newY: newY
                    });

                    showNotification('Text repositioned successfully! ✓', 'success');
                }
            }

            isDraggingText = false;
            draggedTextElement = null;
            draggedOverlayElement = null;
        });

        // Enable drag for ANY text (edited or not)
        function enableTextDragForAnyText(textSpan, textItem, pageNumber) {
            let clickTimeout = null;
            let hasMoved = false;
            let originalOverlay = null;

            textSpan.addEventListener('mousedown', function(e) {
                // Only allow dragging in moveText mode
                if (currentTool !== 'moveText') return;

                // Don't start drag on double-click
                if (e.detail > 1) return;

                hasMoved = false;
                const startX = e.clientX;
                const startY = e.clientY;

                // Small delay to distinguish click from drag
                clickTimeout = setTimeout(() => {
                    isDraggingText = true;
                    draggedTextElement = textSpan;

                    const index = parseInt(textSpan.dataset.index);
                    const page = parseInt(textSpan.dataset.page);

                    // Check if this text was already edited
                    const existingEditIndex = textEdits.findIndex(edit =>
                        edit.page === page && edit.index === index
                    );

                    // If not edited yet, create a text edit entry for repositioning
                    if (existingEditIndex < 0) {
                        const currentX = parseFloat(textSpan.style.left);
                        const currentY = parseFloat(textSpan.style.top);

                        // Create white overlay to cover original text
                        const overlay = document.createElement('div');
                        overlay.className = 'text-edit-overlay';
                        overlay.style.position = 'absolute';
                        overlay.style.left = textSpan.style.left;
                        overlay.style.top = textSpan.style.top;
                        overlay.style.width = textSpan.offsetWidth + 'px';
                        overlay.style.height = textSpan.style.fontSize;
                        overlay.style.backgroundColor = 'white';
                        overlay.style.zIndex = '1';
                        overlay.dataset.editIndex = index;
                        overlay.dataset.editPage = page;

                        textSpan.parentElement.insertBefore(overlay, textSpan);
                        originalOverlay = overlay;

                        // Mark as edited visually
                        textSpan.classList.add('edited');
                        textSpan.style.zIndex = '2';
                        textSpan.style.display = 'inline-block';

                        // Create edit entry (text not changed, just repositioned)
                        textEdits.push({
                            page: page,
                            index: index,
                            originalText: textItem.str,
                            newText: textItem.str,  // Same text, just repositioned
                            x: currentX,
                            y: currentY,
                            originalX: currentX,
                            originalY: currentY,
                            fontSize: parseFloat(textSpan.style.fontSize),
                            fontName: textItem.fontName,
                            width: textSpan.offsetWidth
                        });

                        updateEditedTextList();
                    } else {
                        // Find existing overlay
                        draggedOverlayElement = document.querySelector(
                            `.text-edit-overlay[data-edit-index="${index}"][data-edit-page="${page}"]`
                        );
                    }

                    const rect = textSpan.getBoundingClientRect();
                    const layerRect = textLayer.getBoundingClientRect();

                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;

                    textSpan.classList.add('dragging');
                    e.preventDefault();
                }, 150);

                // Track if mouse moves before timeout
                const checkMove = (moveEvent) => {
                    const dx = Math.abs(moveEvent.clientX - startX);
                    const dy = Math.abs(moveEvent.clientY - startY);
                    if (dx > 5 || dy > 5) {
                        hasMoved = true;
                    }
                };

                document.addEventListener('mousemove', checkMove);

                // Clean up on mouseup
                const cleanupCheck = () => {
                    document.removeEventListener('mousemove', checkMove);
                    document.removeEventListener('mouseup', cleanupCheck);
                    if (!hasMoved && clickTimeout) {
                        clearTimeout(clickTimeout);
                    }
                };
                document.addEventListener('mouseup', cleanupCheck);
            });

            // Prevent click event from firing when we dragged
            textSpan.addEventListener('click', function(e) {
                if (hasMoved) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }, true);
        }

        // Change page
        async function changePage(delta) {
            const newPage = currentPage + delta;
            if (newPage >= 1 && newPage <= totalPages) {
                // Clear OCR selection and hide extract button when changing pages
                ocrSelection = null;
                document.getElementById('extractOCRBtn').style.display = 'none';

                await renderPage(newPage);
            }
        }

        // Set current tool
        function setTool(tool) {
            // Check if tool button is disabled (for image-only PDFs)
            const toolButton = document.getElementById(tool + 'Tool');
            if (toolButton && toolButton.disabled) {
                console.log(`⚠️  Tool "${tool}" is disabled (image-only PDF)`);
                return;
            }

            currentTool = tool;

            // Update tool button states
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            toolButton.classList.add('active');

            // Change cursor
            if (tool === 'editText' || tool === 'moveText') {
                annCanvas.style.cursor = 'default';
                annCanvas.style.pointerEvents = 'none';  // Allow clicks to pass through to text layer
            } else if (tool === 'ocrSelect' || tool === 'erase') {
                annCanvas.style.cursor = 'crosshair';
                annCanvas.style.pointerEvents = 'auto';
                // Clear any existing selection when entering OCR/Erase mode
                ocrSelection = null;
                document.getElementById('extractOCRBtn').style.display = 'none';
            } else {
                annCanvas.style.cursor = 'crosshair';
                annCanvas.style.pointerEvents = 'auto';
            }

            // Clear OCR selection when switching away from OCR/Erase tool
            if (tool !== 'ocrSelect' && tool !== 'erase' && ocrSelection) {
                ocrSelection = null;
                document.getElementById('extractOCRBtn').style.display = 'none';
                redrawAnnotations();
            }

            updateTextLayerVisibility();
        }

        // Brush size display
        brushSize.addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
        });

        // Canvas mouse events for drawing
        annCanvas.addEventListener('mousedown', startAnnotation);
        annCanvas.addEventListener('mousemove', drawAnnotation);
        annCanvas.addEventListener('mouseup', endAnnotation);

        function startAnnotation(e) {
            if (currentTool === 'editText') return;

            const rect = annCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Handle OCR selection mode and Erase mode
            if (currentTool === 'ocrSelect' || currentTool === 'erase') {
                isSelectingOCR = true;
                ocrSelectionStart = { x, y };
                ocrSelection = { x, y, width: 0, height: 0, page: currentPage };
                // Hide extract button while drawing
                document.getElementById('extractOCRBtn').style.display = 'none';
                return;
            }

            if (currentTool === 'addText') {
                const text = prompt('Enter text to add:');
                if (text) {
                    annotations.push({
                        type: 'text',
                        x,
                        y,
                        text,
                        color: document.getElementById('textColor').value,
                        fontSize: document.getElementById('fontSize').value,
                        page: currentPage
                    });
                    redrawAnnotations();
                }
                return;
            }

            isDrawing = true;
            currentAnnotation = {
                type: currentTool,
                startX: x,
                startY: y,
                color: colorPicker.value,
                size: parseInt(brushSize.value),
                page: currentPage,
                points: currentTool === 'draw' ? [[x, y]] : []
            };
        }

        function drawAnnotation(e) {
            // Handle OCR selection drawing and Erase selection drawing
            if (isSelectingOCR && (currentTool === 'ocrSelect' || currentTool === 'erase')) {
                const rect = annCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Update selection rectangle
                ocrSelection.width = x - ocrSelectionStart.x;
                ocrSelection.height = y - ocrSelectionStart.y;

                // Draw the selection rectangle
                drawOCRSelection();
                return;
            }

            if (!isDrawing || currentTool === 'editText' || currentTool === 'addText') return;

            const rect = annCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'draw') {
                currentAnnotation.points.push([x, y]);

                // Draw current stroke in real-time
                annCtx.strokeStyle = currentAnnotation.color;
                annCtx.lineWidth = currentAnnotation.size;
                annCtx.lineCap = 'round';
                annCtx.beginPath();
                const points = currentAnnotation.points;
                annCtx.moveTo(points[points.length - 2][0], points[points.length - 2][1]);
                annCtx.lineTo(x, y);
                annCtx.stroke();
            } else {
                // For shapes, show preview
                redrawAnnotations();
                annCtx.strokeStyle = currentAnnotation.color;
                annCtx.lineWidth = currentAnnotation.size;

                if (currentTool === 'rectangle') {
                    const width = x - currentAnnotation.startX;
                    const height = y - currentAnnotation.startY;
                    annCtx.strokeRect(currentAnnotation.startX, currentAnnotation.startY, width, height);
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt(
                        Math.pow(x - currentAnnotation.startX, 2) +
                        Math.pow(y - currentAnnotation.startY, 2)
                    );
                    annCtx.beginPath();
                    annCtx.arc(currentAnnotation.startX, currentAnnotation.startY, radius, 0, 2 * Math.PI);
                    annCtx.stroke();
                }
            }
        }

        function endAnnotation(e) {
            // Handle OCR selection completion
            if (isSelectingOCR && currentTool === 'ocrSelect') {
                isSelectingOCR = false;

                // Normalize negative widths/heights
                if (ocrSelection.width < 0) {
                    ocrSelection.x += ocrSelection.width;
                    ocrSelection.width = Math.abs(ocrSelection.width);
                }
                if (ocrSelection.height < 0) {
                    ocrSelection.y += ocrSelection.height;
                    ocrSelection.height = Math.abs(ocrSelection.height);
                }

                // Only show extract button if selection is large enough (min 20x20)
                if (ocrSelection.width > 20 && ocrSelection.height > 20) {
                    document.getElementById('extractOCRBtn').style.display = 'flex';
                    console.log('OCR selection completed:', ocrSelection);
                } else {
                    // Selection too small, clear it
                    ocrSelection = null;
                    redrawAnnotations();
                }
                return;
            }

            // Handle Redact selection completion - automatically remove area
            if (isSelectingOCR && currentTool === 'erase') {
                isSelectingOCR = false;

                // Normalize negative widths/heights
                if (ocrSelection.width < 0) {
                    ocrSelection.x += ocrSelection.width;
                    ocrSelection.width = Math.abs(ocrSelection.width);
                }
                if (ocrSelection.height < 0) {
                    ocrSelection.y += ocrSelection.height;
                    ocrSelection.height = Math.abs(ocrSelection.height);
                }

                // Only erase if selection is large enough (min 10x10)
                if (ocrSelection.width > 10 && ocrSelection.height > 10) {
                    console.log('Erase selection completed:', ocrSelection);
                    // Automatically remove the selected area
                    removeSelectedArea();
                } else {
                    // Selection too small, clear it
                    ocrSelection = null;
                    redrawAnnotations();
                }
                return;
            }

            if (!isDrawing) return;

            const rect = annCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'rectangle' || currentTool === 'circle') {
                currentAnnotation.endX = x;
                currentAnnotation.endY = y;
                annotations.push(currentAnnotation);

                // Add to action history for undo support
                actionHistory.push({
                    type: 'annotation',
                    data: currentAnnotation
                });

                redrawAnnotations();
            } else if (currentTool === 'draw') {
                annotations.push(currentAnnotation);

                // Add to action history for undo support
                actionHistory.push({
                    type: 'annotation',
                    data: currentAnnotation
                });
            }

            isDrawing = false;
            currentAnnotation = null;
        }

        // Redraw all annotations
        function redrawAnnotations() {
            annCtx.clearRect(0, 0, annCanvas.width, annCanvas.height);

            annotations.filter(ann => ann.page === currentPage).forEach(ann => {
                if (ann.type === 'text') {
                    annCtx.fillStyle = ann.color;
                    annCtx.font = `${ann.fontSize}px Arial`;
                    annCtx.fillText(ann.text, ann.x, ann.y);
                } else if (ann.type === 'draw') {
                    annCtx.strokeStyle = ann.color;
                    annCtx.lineWidth = ann.size;
                    annCtx.lineCap = 'round';
                    annCtx.beginPath();
                    ann.points.forEach((point, index) => {
                        if (index === 0) {
                            annCtx.moveTo(point[0], point[1]);
                        } else {
                            annCtx.lineTo(point[0], point[1]);
                        }
                    });
                    annCtx.stroke();
                } else if (ann.type === 'rectangle') {
                    annCtx.strokeStyle = ann.color;
                    annCtx.lineWidth = ann.size;
                    const width = ann.endX - ann.startX;
                    const height = ann.endY - ann.startY;
                    annCtx.strokeRect(ann.startX, ann.startY, width, height);
                } else if (ann.type === 'circle') {
                    annCtx.strokeStyle = ann.color;
                    annCtx.lineWidth = ann.size;
                    const radius = Math.sqrt(
                        Math.pow(ann.endX - ann.startX, 2) +
                        Math.pow(ann.endY - ann.startY, 2)
                    );
                    annCtx.beginPath();
                    annCtx.arc(ann.startX, ann.startY, radius, 0, 2 * Math.PI);
                    annCtx.stroke();
                }
            });

            // Also draw OCR selection if active
            if (ocrSelection && ocrSelection.page === currentPage) {
                annCtx.save();
                annCtx.strokeStyle = '#2196F3';
                annCtx.lineWidth = 3;
                annCtx.setLineDash([10, 5]);
                annCtx.fillStyle = 'rgba(33, 150, 243, 0.1)';
                annCtx.fillRect(ocrSelection.x, ocrSelection.y, ocrSelection.width, ocrSelection.height);
                annCtx.strokeRect(ocrSelection.x, ocrSelection.y, ocrSelection.width, ocrSelection.height);
                annCtx.restore();
            }

            // Draw removed areas as white rectangles
            removedAreas.filter(area => area.page === currentPage).forEach(area => {
                annCtx.fillStyle = 'white';
                annCtx.fillRect(area.x, area.y, area.width, area.height);
            });
        }

        // Undo last annotation or signature
        function undo() {
            if (actionHistory.length === 0) {
                showAlert('Nothing to undo', 'info');
                return;
            }

            // Get the last action from history
            const lastAction = actionHistory.pop();

            // Handle different action types
            if (lastAction.type === 'annotation') {
                // Find and remove this annotation from the annotations array
                const index = annotations.findIndex(ann => ann === lastAction.data);
                if (index !== -1) {
                    annotations.splice(index, 1);
                    redrawAnnotations();
                }
                showAlert('Drawing removed', 'success');
            } else if (lastAction.type === 'signature') {
                // Find and remove this signature from the signatures array
                const index = signatures.findIndex(sig => sig === lastAction.data);
                if (index !== -1) {
                    signatures.splice(index, 1);
                    renderSignatures();
                }
                showAlert('Signature removed', 'success');
            } else if (lastAction.type === 'textEditCreate') {
                // Remove the text edit that was created
                const editToRemove = lastAction.edit;
                const index = textEdits.findIndex(edit =>
                    edit.page === editToRemove.page && edit.index === editToRemove.index
                );
                if (index !== -1) {
                    textEdits.splice(index, 1);
                    renderPage(currentPage); // Re-render to remove visual changes
                    updateEditedTextList();
                }
                showAlert('Text edit removed', 'success');
            } else if (lastAction.type === 'textEditUpdate') {
                // Restore previous state of the text edit
                textEdits[lastAction.editIndex] = lastAction.previousState;
                renderPage(currentPage); // Re-render to show previous state
                updateEditedTextList();
                showAlert('Text edit reverted', 'success');
            } else if (lastAction.type === 'textMove') {
                // Restore previous position
                const edit = textEdits[lastAction.editIndex];
                if (edit) {
                    edit.x = lastAction.previousX;
                    edit.y = lastAction.previousY;
                    renderPage(currentPage); // Re-render to show previous position
                }
                showAlert('Text position restored', 'success');
            } else if (lastAction.type === 'removeArea') {
                // Remove the last removed area
                const index = removedAreas.findIndex(area => area === lastAction.data);
                if (index !== -1) {
                    removedAreas.splice(index, 1);
                    redrawAnnotations();
                }
                showAlert('Removed area restored', 'success');
            }
        }

        // Clear all annotations
        function clearAnnotations() {
            showConfirm('Are you sure you want to clear all annotations (not text edits)?', (result) => {
                if (result) {
                    annotations = [];
                    redrawAnnotations();
                }
            });
        }

        // === OCR Selection Functions ===

        // Draw OCR selection rectangle
        function drawOCRSelection() {
            if (!ocrSelection) return;

            // Redraw all existing annotations first
            redrawAnnotations();

            // Draw OCR selection with dashed blue outline
            annCtx.save();
            annCtx.strokeStyle = '#2196F3';
            annCtx.lineWidth = 3;
            annCtx.setLineDash([10, 5]);
            annCtx.fillStyle = 'rgba(33, 150, 243, 0.1)';

            annCtx.fillRect(ocrSelection.x, ocrSelection.y, ocrSelection.width, ocrSelection.height);
            annCtx.strokeRect(ocrSelection.x, ocrSelection.y, ocrSelection.width, ocrSelection.height);

            annCtx.restore();
        }

        // Extract text from selected area using OCR
        async function extractTextFromSelection() {
            if (!ocrSelection) {
                showAlert('No area selected. Please drag to select an area first.', 'warning');
                return;
            }

            const loadingDiv = document.getElementById('loading');
            const loadingText = loadingDiv.querySelector('div:last-child');
            const originalText = loadingText.textContent;
            loadingDiv.style.display = 'flex';
            loadingText.textContent = 'Extracting text from selection...';

            try {
                // Initialize OCR worker
                const worker = await initOCRWorker();

                // Get the current page
                const page = await pdfDoc.getPage(currentPage);
                const viewport = page.getViewport({ scale: 2.0 }); // Higher res for better OCR

                // Create temporary canvas for OCR
                const ocrCanvas = document.createElement('canvas');
                ocrCanvas.width = viewport.width;
                ocrCanvas.height = viewport.height;
                const ocrCtx = ocrCanvas.getContext('2d');

                // Render full page
                await page.render({
                    canvasContext: ocrCtx,
                    viewport: viewport
                }).promise;

                // Calculate scaling factor (canvas scale / display scale)
                const scale = viewport.width / pdfCanvas.width;

                // Crop to selected area
                const cropCanvas = document.createElement('canvas');
                const cropX = ocrSelection.x * scale;
                const cropY = ocrSelection.y * scale;
                const cropWidth = ocrSelection.width * scale;
                const cropHeight = ocrSelection.height * scale;

                cropCanvas.width = cropWidth;
                cropCanvas.height = cropHeight;
                const cropCtx = cropCanvas.getContext('2d');

                cropCtx.drawImage(
                    ocrCanvas,
                    cropX, cropY, cropWidth, cropHeight,
                    0, 0, cropWidth, cropHeight
                );

                console.log(`Running OCR on area: ${cropWidth}x${cropHeight}px`);

                // Run OCR on cropped area
                const { data } = await worker.recognize(cropCanvas);

                console.log(`OCR completed: ${data.words.length} words, confidence: ${data.confidence.toFixed(2)}%`);

                loadingDiv.style.display = 'none';
                loadingText.textContent = originalText;

                // Store extraction result
                const extraction = {
                    rect: { ...ocrSelection },
                    text: data.text,
                    words: data.words,
                    confidence: data.confidence,
                    page: currentPage
                };
                ocrExtractions.push(extraction);

                // Show results modal
                showOCRResults(extraction);

                // Hide extract button
                document.getElementById('extractOCRBtn').style.display = 'none';

            } catch (error) {
                console.error('OCR extraction error:', error);
                loadingDiv.style.display = 'none';
                loadingText.textContent = originalText;
                showAlert('OCR extraction failed: ' + error.message, 'error');
            }
        }

        // Remove selected area by covering it with white rectangle
        function removeSelectedArea() {
            if (!ocrSelection) {
                showAlert('No area selected. Please drag to select an area first.', 'warning');
                return;
            }

            // Store the area to be removed
            const areaToRemove = {
                x: ocrSelection.x,
                y: ocrSelection.y,
                width: ocrSelection.width,
                height: ocrSelection.height,
                page: currentPage
            };

            removedAreas.push(areaToRemove);

            // Track in action history for undo
            actionHistory.push({
                type: 'removeArea',
                data: areaToRemove
            });

            console.log(`Area removed: ${Math.round(areaToRemove.width)}x${Math.round(areaToRemove.height)}px on page ${currentPage}`);

            // Clear selection
            ocrSelection = null;
            isSelectingOCR = false;

            // Hide buttons
            document.getElementById('extractOCRBtn').style.display = 'none';

            // Redraw to show removed area
            redrawAnnotations();

            showNotification('Area removed successfully! It will be covered in the exported PDF. ✓', 'success');
        }

        // Show OCR results in modal
        function showOCRResults(extraction) {
            const modal = document.getElementById('ocrResultsModal');
            const overlay = document.getElementById('modalOverlay');
            const textarea = document.getElementById('ocrResultsText');
            const areaInfo = document.getElementById('ocrAreaInfo');
            const wordCount = document.getElementById('ocrWordCount');

            textarea.value = extraction.text;
            areaInfo.textContent = `${Math.round(extraction.rect.width)}×${Math.round(extraction.rect.height)}px on page ${extraction.page}`;
            wordCount.textContent = `${extraction.words.length} words detected | Confidence: ${extraction.confidence.toFixed(1)}%`;

            // Set estimated font size based on selection height
            const estimatedFontSize = Math.max(10, Math.min(48, Math.round(extraction.rect.height * 0.7)));
            document.getElementById('ocrFontSize').value = estimatedFontSize;
            document.getElementById('ocrFontSizeValue').textContent = estimatedFontSize;

            modal.classList.add('active');
            overlay.classList.add('active');
            textarea.focus();
            textarea.select();
        }

        // Set OCR text alignment
        function setOCRAlign(align) {
            currentOCRAlignment = align;

            // Update button states
            document.querySelectorAll('.align-btn').forEach(btn => {
                if (btn.dataset.align === align) {
                    btn.classList.add('active');
                    btn.style.borderColor = '#2196F3';
                } else {
                    btn.classList.remove('active');
                    btn.style.borderColor = '#ddd';
                }
            });
        }

        // Close OCR results modal
        function closeOCRModal() {
            document.getElementById('ocrResultsModal').classList.remove('active');
            document.getElementById('modalOverlay').classList.remove('active');

            // Clear selection
            ocrSelection = null;
            redrawAnnotations();
        }

        // Copy OCR text to clipboard
        async function copyOCRText() {
            const textarea = document.getElementById('ocrResultsText');
            try {
                await navigator.clipboard.writeText(textarea.value);
                // Visual feedback
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✓ Copied!';
                btn.style.background = '#4CAF50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#2196F3';
                }, 2000);
            } catch (error) {
                // Fallback for older browsers
                textarea.select();
                document.execCommand('copy');
                showAlert('Text copied to clipboard!', 'success');
            }
        }

        // Insert OCR text as smart overlay on PDF
        function insertOCRAsText() {
            const text = document.getElementById('ocrResultsText').value.trim();
            if (!text) {
                showAlert('No text to insert.', 'warning');
                return;
            }

            // Find the last extraction's position
            const lastExtraction = ocrExtractions[ocrExtractions.length - 1];
            if (lastExtraction && lastExtraction.rect) {
                const rect = lastExtraction.rect;

                // Get style values from controls
                const fontSize = parseInt(document.getElementById('ocrFontSize').value);
                const textColor = document.getElementById('ocrTextColor').value;
                const bgColor = document.getElementById('ocrBgColor').value;
                const bgOpacity = parseInt(document.getElementById('ocrBgOpacity').value) / 100;
                const textOpacity = parseInt(document.getElementById('ocrTextOpacity').value) / 100;
                const fontFamily = document.getElementById('ocrFontFamily').value;

                // Convert hex color to rgba with opacity
                const r = parseInt(bgColor.slice(1, 3), 16);
                const g = parseInt(bgColor.slice(3, 5), 16);
                const b = parseInt(bgColor.slice(5, 7), 16);
                const bgColorRgba = `rgba(${r}, ${g}, ${b}, ${bgOpacity})`;

                // Create overlay object
                const overlay = {
                    id: 'overlay-' + Date.now(),
                    text: text,
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    fontSize: fontSize,
                    color: textColor,
                    bgColor: bgColorRgba,
                    textOpacity: textOpacity,
                    fontFamily: fontFamily,
                    alignment: currentOCRAlignment,
                    page: currentPage
                };

                textOverlays.push(overlay);
                renderTextOverlays();
                closeOCRModal();

                console.log('✓ Text overlay created:', overlay);
            }
        }

        // Render all text overlays for current page
        function renderTextOverlays() {
            const overlayLayer = document.getElementById('overlayLayer');
            overlayLayer.innerHTML = '';

            // Filter overlays for current page
            const pageOverlays = textOverlays.filter(o => o.page === currentPage);

            pageOverlays.forEach(overlay => {
                const div = document.createElement('div');
                div.className = 'text-overlay';
                div.id = overlay.id;
                div.textContent = overlay.text;

                // Position and style
                div.style.left = overlay.x + 'px';
                div.style.top = overlay.y + 'px';
                div.style.width = overlay.width + 'px';
                div.style.minHeight = overlay.height + 'px';
                div.style.fontSize = overlay.fontSize + 'px';

                // Apply text color with opacity
                const textOpacity = overlay.textOpacity !== undefined ? overlay.textOpacity : 1;
                if (textOpacity < 1) {
                    // Convert hex to rgba with opacity
                    const textColor = overlay.color;
                    const r = parseInt(textColor.slice(1, 3), 16);
                    const g = parseInt(textColor.slice(3, 5), 16);
                    const b = parseInt(textColor.slice(5, 7), 16);
                    div.style.color = `rgba(${r}, ${g}, ${b}, ${textOpacity})`;
                } else {
                    div.style.color = overlay.color;
                }

                div.style.backgroundColor = overlay.bgColor;
                div.style.textAlign = overlay.alignment;
                div.style.fontFamily = overlay.fontFamily || 'Arial, sans-serif';

                // Add delete button
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '×';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteOverlay(overlay.id);
                };
                div.appendChild(deleteBtn);

                // Add resize handles (corners and edges)
                ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'].forEach(position => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${position}`;
                    handle.onmousedown = (e) => {
                        e.stopPropagation();
                        startResize(e, overlay.id, position);
                    };
                    div.appendChild(handle);
                });

                // Click to select
                div.onclick = () => {
                    selectOverlay(overlay.id);
                };

                // Double-click to edit
                div.ondblclick = (e) => {
                    e.stopPropagation();
                    editOverlay(overlay.id);
                };

                // Drag to reposition
                div.onmousedown = (e) => {
                    // Only drag if not clicking delete button or resize handle
                    if (e.target === div) {
                        startDrag(e, overlay.id);
                    }
                };

                overlayLayer.appendChild(div);
            });

            // Update overlay list in sidebar
            renderOverlayList();

            console.log(`✓ Rendered ${pageOverlays.length} overlays on page ${currentPage}`);
        }

        // Select an overlay
        function selectOverlay(overlayId) {
            // Deselect all
            document.querySelectorAll('.text-overlay').forEach(el => {
                el.classList.remove('selected');
            });

            // Select this one
            const element = document.getElementById(overlayId);
            if (element) {
                element.classList.add('selected');
                selectedOverlay = overlayId;
            }
        }

        // Delete an overlay
        function deleteOverlay(overlayId) {
            showConfirm('Delete this text overlay?', (result) => {
                if (result) {
                    textOverlays = textOverlays.filter(o => o.id !== overlayId);
                    renderTextOverlays();
                    selectedOverlay = null;
                    console.log('✓ Overlay deleted:', overlayId);
                }
            });
        }

        // Render overlay list in sidebar
        function renderOverlayList() {
            const overlayList = document.getElementById('overlayList');

            if (textOverlays.length === 0) {
                overlayList.innerHTML = '<em style="font-size: 12px; color: #666;">No overlays yet</em>';
                return;
            }

            overlayList.innerHTML = '';
            textOverlays.forEach((overlay, index) => {
                const item = document.createElement('div');
                item.className = 'overlay-list-item';
                if (selectedOverlay === overlay.id) {
                    item.classList.add('active');
                }

                item.innerHTML = `
                    <div><strong>Overlay ${index + 1}</strong> (Page ${overlay.page})</div>
                    <div class="overlay-text-preview">"${overlay.text.substring(0, 30)}${overlay.text.length > 30 ? '...' : ''}"</div>
                `;

                item.onclick = () => {
                    if (overlay.page !== currentPage) {
                        currentPage = overlay.page;
                        renderPage(currentPage);
                    }
                    selectOverlay(overlay.id);
                };

                overlayList.appendChild(item);
            });
        }

        // Edit an existing overlay
        function editOverlay(overlayId) {
            const overlay = textOverlays.find(o => o.id === overlayId);
            if (!overlay) return;

            // Create edit modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%;">
                    <h3 style="margin: 0 0 20px 0; color: #333;">Edit Text Overlay</h3>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Text:</label>
                        <textarea id="editOverlayText" style="width: 100%; height: 100px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-family: inherit; resize: vertical;">${overlay.text}</textarea>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Font Size:</label>
                            <input type="number" id="editFontSize" value="${overlay.fontSize}" min="8" max="72" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Text Color:</label>
                            <input type="color" id="editTextColor" value="${overlay.color}" style="width: 100%; height: 38px; border: 1px solid #ddd; border-radius: 6px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Background:</label>
                            <input type="color" id="editBgColor" value="${rgbaToHex(overlay.bgColor)}" style="width: 100%; height: 38px; border: 1px solid #ddd; border-radius: 6px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Text Opacity:</label>
                            <input type="range" id="editTextOpacity" value="${(overlay.textOpacity !== undefined ? overlay.textOpacity : 1) * 100}" min="0" max="100" style="width: 100%;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Font Family:</label>
                            <select id="editFontFamily" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                                <option value="Arial, sans-serif" ${(overlay.fontFamily || 'Arial, sans-serif') === 'Arial, sans-serif' ? 'selected' : ''}>Arial</option>
                                <option value="'Times New Roman', serif" ${overlay.fontFamily === "'Times New Roman', serif" ? 'selected' : ''}>Times New Roman</option>
                                <option value="'Courier New', monospace" ${overlay.fontFamily === "'Courier New', monospace" ? 'selected' : ''}>Courier New</option>
                                <option value="Georgia, serif" ${overlay.fontFamily === 'Georgia, serif' ? 'selected' : ''}>Georgia</option>
                                <option value="Verdana, sans-serif" ${overlay.fontFamily === 'Verdana, sans-serif' ? 'selected' : ''}>Verdana</option>
                                <option value="'Trebuchet MS', sans-serif" ${overlay.fontFamily === "'Trebuchet MS', sans-serif" ? 'selected' : ''}>Trebuchet MS</option>
                                <option value="'Comic Sans MS', cursive" ${overlay.fontFamily === "'Comic Sans MS', cursive" ? 'selected' : ''}>Comic Sans MS</option>
                                <option value="Impact, sans-serif" ${overlay.fontFamily === 'Impact, sans-serif' ? 'selected' : ''}>Impact</option>
                                <option value="'Lucida Console', monospace" ${overlay.fontFamily === "'Lucida Console', monospace" ? 'selected' : ''}>Lucida Console</option>
                                <option value="Tahoma, sans-serif" ${overlay.fontFamily === 'Tahoma, sans-serif' ? 'selected' : ''}>Tahoma</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Alignment:</label>
                            <select id="editAlignment" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                                <option value="left" ${overlay.alignment === 'left' ? 'selected' : ''}>Left</option>
                                <option value="center" ${overlay.alignment === 'center' ? 'selected' : ''}>Center</option>
                                <option value="right" ${overlay.alignment === 'right' ? 'selected' : ''}>Right</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="this.closest('div[style*=\\'position: fixed\\']').remove()" style="padding: 10px 20px; background: #f5f5f5; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                        <button onclick="saveOverlayEdit('${overlayId}')" style="padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Save Changes</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Helper function to convert rgba to hex
        function rgbaToHex(rgba) {
            const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (!match) return '#ffffff';
            const r = parseInt(match[1]).toString(16).padStart(2, '0');
            const g = parseInt(match[2]).toString(16).padStart(2, '0');
            const b = parseInt(match[3]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        // Save overlay edits
        function saveOverlayEdit(overlayId) {
            const overlay = textOverlays.find(o => o.id === overlayId);
            if (!overlay) return;

            overlay.text = document.getElementById('editOverlayText').value;
            overlay.fontSize = parseInt(document.getElementById('editFontSize').value);
            overlay.color = document.getElementById('editTextColor').value;

            const bgColor = document.getElementById('editBgColor').value;
            const r = parseInt(bgColor.slice(1, 3), 16);
            const g = parseInt(bgColor.slice(3, 5), 16);
            const b = parseInt(bgColor.slice(5, 7), 16);
            overlay.bgColor = `rgba(${r}, ${g}, ${b}, 0.9)`;

            overlay.textOpacity = parseInt(document.getElementById('editTextOpacity').value) / 100;
            overlay.fontFamily = document.getElementById('editFontFamily').value;
            overlay.alignment = document.getElementById('editAlignment').value;

            renderTextOverlays();
            document.querySelector('div[style*="position: fixed"]').remove();

            console.log('✓ Overlay updated:', overlayId);
        }

        // Drag functionality
        let dragState = null;

        function startDrag(e, overlayId) {
            const overlay = textOverlays.find(o => o.id === overlayId);
            if (!overlay) return;

            selectOverlay(overlayId);

            const element = document.getElementById(overlayId);
            element.classList.add('dragging');

            dragState = {
                overlayId: overlayId,
                startX: e.clientX,
                startY: e.clientY,
                initialX: overlay.x,
                initialY: overlay.y
            };

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
            e.preventDefault();
        }

        function onDrag(e) {
            if (!dragState) return;

            const dx = e.clientX - dragState.startX;
            const dy = e.clientY - dragState.startY;

            const overlay = textOverlays.find(o => o.id === dragState.overlayId);
            if (overlay) {
                overlay.x = dragState.initialX + dx;
                overlay.y = dragState.initialY + dy;

                const element = document.getElementById(dragState.overlayId);
                if (element) {
                    element.style.left = overlay.x + 'px';
                    element.style.top = overlay.y + 'px';
                }
            }
        }

        function endDrag() {
            if (dragState) {
                const element = document.getElementById(dragState.overlayId);
                if (element) {
                    element.classList.remove('dragging');
                }
                dragState = null;
            }
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);
        }

        // Resize functionality
        let resizeState = null;

        function startResize(e, overlayId, position) {
            const overlay = textOverlays.find(o => o.id === overlayId);
            if (!overlay) return;

            selectOverlay(overlayId);

            resizeState = {
                overlayId: overlayId,
                position: position,
                startX: e.clientX,
                startY: e.clientY,
                initialX: overlay.x,
                initialY: overlay.y,
                initialWidth: overlay.width,
                initialHeight: overlay.height
            };

            document.addEventListener('mousemove', onResize);
            document.addEventListener('mouseup', endResize);
            e.preventDefault();
        }

        function onResize(e) {
            if (!resizeState) return;

            const dx = e.clientX - resizeState.startX;
            const dy = e.clientY - resizeState.startY;

            const overlay = textOverlays.find(o => o.id === resizeState.overlayId);
            if (!overlay) return;

            const element = document.getElementById(resizeState.overlayId);
            if (!element) return;

            // Apply resize based on handle position
            switch (resizeState.position) {
                case 'se': // Bottom-right
                    overlay.width = Math.max(50, resizeState.initialWidth + dx);
                    overlay.height = Math.max(20, resizeState.initialHeight + dy);
                    break;
                case 'sw': // Bottom-left
                    overlay.width = Math.max(50, resizeState.initialWidth - dx);
                    overlay.height = Math.max(20, resizeState.initialHeight + dy);
                    overlay.x = resizeState.initialX + (resizeState.initialWidth - overlay.width);
                    break;
                case 'ne': // Top-right
                    overlay.width = Math.max(50, resizeState.initialWidth + dx);
                    overlay.height = Math.max(20, resizeState.initialHeight - dy);
                    overlay.y = resizeState.initialY + (resizeState.initialHeight - overlay.height);
                    break;
                case 'nw': // Top-left
                    overlay.width = Math.max(50, resizeState.initialWidth - dx);
                    overlay.height = Math.max(20, resizeState.initialHeight - dy);
                    overlay.x = resizeState.initialX + (resizeState.initialWidth - overlay.width);
                    overlay.y = resizeState.initialY + (resizeState.initialHeight - overlay.height);
                    break;
                case 'n': // Top edge
                    overlay.height = Math.max(20, resizeState.initialHeight - dy);
                    overlay.y = resizeState.initialY + (resizeState.initialHeight - overlay.height);
                    break;
                case 's': // Bottom edge
                    overlay.height = Math.max(20, resizeState.initialHeight + dy);
                    break;
                case 'e': // Right edge
                    overlay.width = Math.max(50, resizeState.initialWidth + dx);
                    break;
                case 'w': // Left edge
                    overlay.width = Math.max(50, resizeState.initialWidth - dx);
                    overlay.x = resizeState.initialX + (resizeState.initialWidth - overlay.width);
                    break;
            }

            // Update element
            element.style.left = overlay.x + 'px';
            element.style.top = overlay.y + 'px';
            element.style.width = overlay.width + 'px';
            element.style.minHeight = overlay.height + 'px';
        }

        function endResize() {
            resizeState = null;
            document.removeEventListener('mousemove', onResize);
            document.removeEventListener('mouseup', endResize);
        }

        // Keyboard shortcuts for Delete and Backspace
        document.addEventListener('keydown', function(e) {
            // Delete or Backspace key
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Check if we're not in an input field
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA' &&
                    !document.activeElement.isContentEditable) {

                    // Delete selected overlay
                    if (selectedOverlay) {
                        deleteOverlay(selectedOverlay);
                        e.preventDefault();
                    }
                    // Delete selected signature
                    else if (selectedSignature) {
                        deleteSelectedSignature();
                        e.preventDefault();
                    }
                }
            }
        });

        // Save PDF with edits
        async function savePDF() {
            console.log('savePDF called - pdfBytes status:', pdfBytes ? `Length: ${pdfBytes.length}` : 'null/undefined');
            console.log('pdfBytes type:', pdfBytes ? pdfBytes.constructor.name : 'N/A');

            document.getElementById('loading').style.display = 'flex';

            try {
                // Validate pdfBytes
                if (!pdfBytes || pdfBytes.length === 0) {
                    console.error('❌ pdfBytes is invalid!');
                    console.error('  - pdfBytes:', pdfBytes);
                    console.error('  - typeof:', typeof pdfBytes);
                    throw new Error('PDF data not loaded. Please reload the page and try again.');
                }

                console.log('PDF bytes length:', pdfBytes.length);
                console.log('PDF bytes type:', pdfBytes.constructor.name);
                console.log('First few bytes:', Array.from(pdfBytes.slice(0, 10)));

                console.log('📝 Text edits to apply:', textEdits.length);
                console.log('Full textEdits array:', textEdits);

                // Load PDF with pdf-lib
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                const pages = pdfDoc.getPages();

                console.log(`PDF has ${pages.length} pages`);

                // Apply text edits
                for (const edit of textEdits) {
                    const page = pages[edit.page - 1];
                    const { width, height } = page.getSize();

                    console.log(`📄 Page ${edit.page} dimensions: width=${width}, height=${height}`);
                    console.log(`Editing text on page ${edit.page}:`, {
                        original: edit.originalText,
                        new: edit.newText,
                        x: edit.x,
                        y: edit.y,
                        originalX: edit.originalX,
                        originalY: edit.originalY,
                        fontSize: edit.fontSize
                    });

                    // CRITICAL FIX: The PDF is rendered at scale 1.5, so all coordinates
                    // captured from the UI are 1.5x larger than actual PDF coordinates!
                    const SCALE_FACTOR = 1.5; // Must match the viewport scale in renderPage()

                    // Use actual rendered width if available, otherwise estimate
                    const renderedWidth = edit.width || (edit.originalText.length * (edit.fontSize * 0.5));
                    const padding = edit.fontSize * 0.2; // Smaller padding to avoid covering adjacent text

                    // Unscale coordinates for NEW text position
                    const actualX = edit.x / SCALE_FACTOR;
                    const actualY = edit.y / SCALE_FACTOR;

                    // Unscale coordinates for ORIGINAL position (for white rectangle to cover original text)
                    const originalX = (edit.originalX !== undefined ? edit.originalX : edit.x) / SCALE_FACTOR;
                    const originalY = (edit.originalY !== undefined ? edit.originalY : edit.y) / SCALE_FACTOR;
                    const actualFontSize = edit.fontSize / SCALE_FACTOR;
                    const actualPadding = padding / SCALE_FACTOR;
                    const actualWidth = renderedWidth / SCALE_FACTOR;

                    // PDF coordinate conversion for NEW text position:
                    // edit.y is the TOP of the text box (from top of page) - NOT the baseline!
                    const fontAscent = actualFontSize;
                    const baselineFromTop = actualY + fontAscent;
                    const baselineFromBottom = height - baselineFromTop;

                    // PDF coordinate conversion for ORIGINAL position (white rectangle):
                    const originalBaselineFromTop = originalY + fontAscent;
                    const originalBaselineFromBottom = height - originalBaselineFromTop;

                    // Rectangle should cover original text from slightly below baseline to above top of text
                    const rectY = originalBaselineFromBottom - (actualFontSize * 0.2);
                    const rectHeight = actualFontSize * 1.5;

                    console.log(`  SCALE FACTOR: ${SCALE_FACTOR}`);
                    console.log(`  New text (scaled): x=${edit.x}, y=${edit.y}`);
                    console.log(`  New text (unscaled): x=${actualX}, y=${actualY}`);
                    console.log(`  Original (scaled): x=${edit.originalX}, y=${edit.originalY}`);
                    console.log(`  Original (unscaled): x=${originalX}, y=${originalY}`);
                    console.log(`  Font size: ${actualFontSize}`);
                    console.log(`  Captured width (scaled): ${edit.width}px`);
                    console.log(`  Actual width (unscaled): ${actualWidth}px`);
                    console.log(`  New text baseline (from bottom): ${baselineFromBottom}`);
                    console.log(`  Rectangle (at original pos): x=${originalX - actualPadding}, y=${rectY}, width=${actualWidth + actualPadding * 2}, height=${rectHeight}`);

                    // Draw rectangle to cover ORIGINAL text (at original position with padding)
                    page.drawRectangle({
                        x: originalX - actualPadding,
                        y: rectY,
                        width: actualWidth + (actualPadding * 2),
                        height: rectHeight,
                        color: PDFLib.rgb(1, 1, 1), // WHITE
                    });

                    // Draw the new text at the baseline
                    const rgb = hexToRgb(document.getElementById('textColor').value);
                    page.drawText(edit.newText, {
                        x: actualX,
                        y: baselineFromBottom,
                        size: actualFontSize,
                        color: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255)
                    });

                    console.log(`  ✓ Text edit applied successfully`);
                }

                // Apply annotations (text, shapes, etc)
                const ANNOTATION_SCALE = 1.5; // Annotations are drawn at 1.5x scale
                for (const ann of annotations) {
                    const page = pages[ann.page - 1];
                    const { height } = page.getSize();
                    const rgb = hexToRgb(ann.color);

                    if (ann.type === 'text') {
                        page.drawText(ann.text, {
                            x: ann.x,
                            y: height - ann.y,
                            size: parseInt(ann.fontSize),
                            color: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255)
                        });
                    } else if (ann.type === 'draw') {
                        // Draw free-hand drawing (polyline)
                        if (ann.points && ann.points.length > 1) {
                            for (let i = 0; i < ann.points.length - 1; i++) {
                                const [x1, y1] = ann.points[i];
                                const [x2, y2] = ann.points[i + 1];

                                // Scale coordinates and convert to PDF coordinate system
                                const pdfX1 = x1 / ANNOTATION_SCALE;
                                const pdfY1 = height - (y1 / ANNOTATION_SCALE);
                                const pdfX2 = x2 / ANNOTATION_SCALE;
                                const pdfY2 = height - (y2 / ANNOTATION_SCALE);

                                page.drawLine({
                                    start: { x: pdfX1, y: pdfY1 },
                                    end: { x: pdfX2, y: pdfY2 },
                                    thickness: ann.size / ANNOTATION_SCALE,
                                    color: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255),
                                    lineCap: PDFLib.LineCapStyle.Round
                                });
                            }
                        }
                    } else if (ann.type === 'rectangle') {
                        // Draw rectangle
                        const width = ann.endX - ann.startX;
                        const height_rect = ann.endY - ann.startY;

                        // Scale coordinates and convert to PDF coordinate system
                        const pdfX = ann.startX / ANNOTATION_SCALE;
                        const pdfY = height - (ann.startY / ANNOTATION_SCALE) - (height_rect / ANNOTATION_SCALE);
                        const pdfWidth = width / ANNOTATION_SCALE;
                        const pdfHeight = height_rect / ANNOTATION_SCALE;

                        page.drawRectangle({
                            x: pdfX,
                            y: pdfY,
                            width: pdfWidth,
                            height: pdfHeight,
                            borderColor: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255),
                            borderWidth: ann.size / ANNOTATION_SCALE
                        });
                    } else if (ann.type === 'circle') {
                        // Draw circle
                        const radius = Math.sqrt(
                            Math.pow(ann.endX - ann.startX, 2) +
                            Math.pow(ann.endY - ann.startY, 2)
                        );

                        // Scale coordinates and convert to PDF coordinate system
                        const pdfX = ann.startX / ANNOTATION_SCALE;
                        const pdfY = height - (ann.startY / ANNOTATION_SCALE);
                        const pdfRadius = radius / ANNOTATION_SCALE;

                        page.drawCircle({
                            x: pdfX,
                            y: pdfY,
                            size: pdfRadius,
                            borderColor: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255),
                            borderWidth: ann.size / ANNOTATION_SCALE
                        });
                    }
                }

                // Apply removed areas (cover with white rectangles)
                console.log('🗑️  Removed areas to apply:', removedAreas.length);
                const REMOVED_AREA_SCALE = 1.5; // Removed areas are captured at 1.5x scale
                for (const area of removedAreas) {
                    const page = pages[area.page - 1];
                    const { height } = page.getSize();

                    // Scale coordinates and dimensions
                    const pdfX = area.x / REMOVED_AREA_SCALE;
                    const pdfY = height - (area.y / REMOVED_AREA_SCALE) - (area.height / REMOVED_AREA_SCALE);
                    const pdfWidth = area.width / REMOVED_AREA_SCALE;
                    const pdfHeight = area.height / REMOVED_AREA_SCALE;

                    console.log(`  Removing area on page ${area.page}:`, {
                        x: pdfX,
                        y: pdfY,
                        width: pdfWidth,
                        height: pdfHeight
                    });

                    // Draw white rectangle to cover the area
                    page.drawRectangle({
                        x: pdfX,
                        y: pdfY,
                        width: pdfWidth,
                        height: pdfHeight,
                        color: PDFLib.rgb(1, 1, 1), // White
                        borderWidth: 0
                    });
                }

                // Helper function to map CSS font families to PDF standard fonts
                const mapFontFamily = (fontFamily) => {
                    if (!fontFamily) return PDFLib.StandardFonts.Helvetica;

                    const fontLower = fontFamily.toLowerCase();

                    // Monospace fonts (check before serif to avoid conflicts)
                    if (fontLower.includes('courier') || fontLower.includes('monospace') || fontLower.includes('lucida console')) {
                        return PDFLib.StandardFonts.Courier;
                    }

                    // Serif fonts (check for specific fonts OR 'serif' but NOT 'sans-serif')
                    if (fontLower.includes('times') || fontLower.includes('georgia')) {
                        return PDFLib.StandardFonts.TimesRoman;
                    }
                    // Only match plain 'serif' if it's not 'sans-serif'
                    if (fontLower.includes('serif') && !fontLower.includes('sans')) {
                        return PDFLib.StandardFonts.TimesRoman;
                    }

                    // Default to Helvetica for all sans-serif fonts (Arial, Verdana, Tahoma, etc.)
                    return PDFLib.StandardFonts.Helvetica;
                };

                // Apply text overlays (OCR-extracted text)
                console.log('📝 Text overlays to apply:', textOverlays.length);
                for (const overlay of textOverlays) {
                    const page = pages[overlay.page - 1];
                    const { height } = page.getSize();

                    // Scale factor (same as viewport scale)
                    const SCALE_FACTOR = 1.5;

                    // Unscale coordinates and dimensions
                    const actualX = overlay.x / SCALE_FACTOR;
                    const actualY = overlay.y / SCALE_FACTOR;
                    const actualWidth = overlay.width / SCALE_FACTOR;
                    const actualHeight = overlay.height / SCALE_FACTOR;
                    const actualFontSize = overlay.fontSize / SCALE_FACTOR;

                    // Convert coordinates (PDF uses bottom-left origin)
                    const pdfX = actualX;
                    const pdfY = height - actualY - actualHeight;

                    console.log(`  Overlay on page ${overlay.page}:`, {
                        text: overlay.text.substring(0, 30),
                        x: actualX,
                        y: actualY,
                        pdfY: pdfY,
                        fontSize: actualFontSize,
                        fontFamily: overlay.fontFamily
                    });

                    // Draw background rectangle if visible (will be drawn AFTER calculating text height)

                    // Parse text color and opacity
                    const textColor = hexToRgb(overlay.color);
                    const textOpacity = overlay.textOpacity !== undefined ? overlay.textOpacity : 1;

                    // Embed font based on selected font family
                    const pdfFont = mapFontFamily(overlay.fontFamily);
                    const font = await pdfDoc.embedFont(pdfFont);
                    console.log(`    Using PDF font: ${pdfFont} (from ${overlay.fontFamily})`);

                    // CSS padding equivalent (4px top/bottom, 8px left/right scaled down)
                    const paddingX = 8 / SCALE_FACTOR;
                    const paddingY = 4 / SCALE_FACTOR;

                    // Calculate available width for text (box width minus padding)
                    const availableWidth = actualWidth - (2 * paddingX);

                    // Word wrapping function to break text into lines that fit the available width
                    // Supports both word-level and character-level breaking (like CSS word-wrap: break-word)
                    const wrapText = (text, font, fontSize, maxWidth) => {
                        const paragraphs = text.split(/\r?\n/); // Preserve explicit line breaks
                        const wrappedLines = [];

                        paragraphs.forEach(paragraph => {
                            if (paragraph.trim().length === 0) {
                                wrappedLines.push(''); // Preserve empty lines
                                return;
                            }

                            const words = paragraph.split(' ');
                            let currentLine = '';

                            words.forEach((word, index) => {
                                const testLine = currentLine ? currentLine + ' ' + word : word;
                                const testWidth = font.widthOfTextAtSize(testLine, fontSize);

                                if (testWidth <= maxWidth) {
                                    // Word fits on current line
                                    currentLine = testLine;
                                } else {
                                    // Word doesn't fit - check if word itself is too long
                                    const wordWidth = font.widthOfTextAtSize(word, fontSize);

                                    if (currentLine) {
                                        // Save current line before processing the word
                                        wrappedLines.push(currentLine);
                                        currentLine = '';
                                    }

                                    if (wordWidth <= maxWidth) {
                                        // Word fits on its own line
                                        currentLine = word;
                                    } else {
                                        // Word is too long - break it at character level (like CSS word-wrap: break-word)
                                        let remainingWord = word;
                                        while (remainingWord.length > 0) {
                                            let charCount = remainingWord.length;
                                            let testWord = remainingWord;

                                            // Find how many characters fit
                                            while (charCount > 0 && font.widthOfTextAtSize(testWord, fontSize) > maxWidth) {
                                                charCount--;
                                                testWord = remainingWord.substring(0, charCount);
                                            }

                                            if (charCount === 0) {
                                                // Even single character doesn't fit - force at least one char
                                                charCount = 1;
                                                testWord = remainingWord.substring(0, 1);
                                            }

                                            wrappedLines.push(testWord);
                                            remainingWord = remainingWord.substring(charCount);
                                        }
                                    }
                                }
                            });

                            // Add remaining text
                            if (currentLine) {
                                wrappedLines.push(currentLine);
                            }
                        });

                        return wrappedLines;
                    };

                    // Wrap text to fit within box width
                    const lines = wrapText(overlay.text, font, actualFontSize, availableWidth);
                    const lineHeight = actualFontSize * 1.2; // 20% line spacing

                    // Calculate font metrics
                    const textHeightAboveBaseline = actualFontSize * 0.75; // Approximate ascent
                    const textHeightBelowBaseline = actualFontSize * 0.25; // Approximate descent

                    // Calculate actual text height needed (matches CSS minHeight behavior)
                    const textOnlyHeight = (lines.length * lineHeight) - (lineHeight - actualFontSize);
                    const calculatedHeight = textOnlyHeight + (2 * paddingY);

                    // Use the larger of: original box height OR calculated text height
                    const finalHeight = Math.max(actualHeight, calculatedHeight);

                    // Recalculate pdfY with final height (keeps box at same TOP position)
                    // When height increases, we need to move the bottom (pdfY) down
                    const pdfYFinal = height - actualY - finalHeight;

                    console.log(`  Text wrapping: ${lines.length} lines, calculated height: ${calculatedHeight.toFixed(1)}px, using: ${finalHeight.toFixed(1)}px`);
                    console.log(`  Position: pdfY adjusted from ${pdfY.toFixed(1)} to ${pdfYFinal.toFixed(1)} (height increased by ${(finalHeight - actualHeight).toFixed(1)}px)`);

                    // Draw background rectangle FIRST (behind text) with calculated height
                    const bgMatch = overlay.bgColor.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/);
                    if (bgMatch) {
                        const bgR = parseInt(bgMatch[1]) / 255;
                        const bgG = parseInt(bgMatch[2]) / 255;
                        const bgB = parseInt(bgMatch[3]) / 255;
                        const bgOpacity = bgMatch[4] !== undefined ? parseFloat(bgMatch[4]) : 1;

                        console.log(`    Background: rgb(${bgMatch[1]}, ${bgMatch[2]}, ${bgMatch[3]}) opacity=${bgOpacity}, height=${finalHeight.toFixed(1)}px`);

                        if (bgOpacity > 0) {
                            page.drawRectangle({
                                x: pdfX,
                                y: pdfYFinal, // Use adjusted Y position
                                width: actualWidth,
                                height: finalHeight, // Use calculated height that fits all text
                                color: PDFLib.rgb(bgR, bgG, bgB),
                                opacity: bgOpacity,
                                borderWidth: 0
                            });
                        }
                    } else {
                        console.warn(`    Could not parse background color: ${overlay.bgColor}`);
                    }

                    // Start from TOP with padding (like CSS), not vertically centered
                    // In PDF coords: pdfYFinal is bottom of box, so add height to get top, then subtract padding
                    const startY = pdfYFinal + finalHeight - paddingY - textHeightAboveBaseline;

                    // Draw each line
                    lines.forEach((line, index) => {
                        // Skip empty lines but preserve spacing
                        if (line.trim().length === 0) return;

                        // Calculate text width for this line
                        const textWidth = font.widthOfTextAtSize(line, actualFontSize);

                        // Calculate X position based on alignment
                        let textX = pdfX + paddingX;
                        if (overlay.alignment === 'center') {
                            textX = pdfX + (actualWidth - textWidth) / 2;
                        } else if (overlay.alignment === 'right') {
                            textX = pdfX + actualWidth - textWidth - paddingX;
                        }

                        // Calculate Y position for this line (going down from top for each line)
                        const lineY = startY - (index * lineHeight);

                        // Draw text line
                        page.drawText(line, {
                            x: textX,
                            y: lineY,
                            size: actualFontSize,
                            font: font,
                            color: PDFLib.rgb(
                                textColor.r / 255,
                                textColor.g / 255,
                                textColor.b / 255
                            ),
                            opacity: textOpacity
                        });
                    });

                    console.log(`  ✓ Overlay applied successfully`);
                }

                // Apply signatures
                console.log('📝 Signatures to apply:', signatures.length);
                for (const signature of signatures) {
                    const page = pages[signature.page - 1];
                    const { height } = page.getSize();

                    // Scale factor (same as viewport scale)
                    const SCALE_FACTOR = 1.5;

                    // Unscale coordinates and dimensions
                    const actualX = signature.x / SCALE_FACTOR;
                    const actualY = signature.y / SCALE_FACTOR;
                    const actualWidth = signature.width / SCALE_FACTOR;
                    const actualHeight = signature.height / SCALE_FACTOR;

                    // Convert coordinates (PDF uses bottom-left origin)
                    const pdfX = actualX;
                    const pdfY = height - actualY - actualHeight;

                    console.log(`  Signature on page ${signature.page}:`, {
                        x: actualX,
                        y: actualY,
                        pdfY: pdfY,
                        width: actualWidth,
                        height: actualHeight
                    });

                    // Embed the signature image
                    const imageBytes = await fetch(signature.image).then(res => res.arrayBuffer());
                    let signatureImage;

                    // Determine image type and embed
                    if (signature.image.startsWith('data:image/png')) {
                        signatureImage = await pdfDoc.embedPng(imageBytes);
                    } else if (signature.image.startsWith('data:image/jpeg') || signature.image.startsWith('data:image/jpg')) {
                        signatureImage = await pdfDoc.embedJpg(imageBytes);
                    } else {
                        // Default to PNG
                        signatureImage = await pdfDoc.embedPng(imageBytes);
                    }

                    // Draw the signature image
                    page.drawImage(signatureImage, {
                        x: pdfX,
                        y: pdfY,
                        width: actualWidth,
                        height: actualHeight
                    });

                    console.log(`  ✓ Signature applied successfully`);
                }

                // Save the PDF
                console.log('💾 Saving PDF with modifications...');
                const pdfBytesModified = await pdfDoc.save();
                console.log(`✓ PDF saved! Size: ${pdfBytesModified.length} bytes`);

                // Download the file
                const blob = new Blob([pdfBytesModified], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = document.getElementById('docName').value + '.pdf';
                a.download = filename;
                console.log(`📥 Downloading: ${filename}`);
                a.click();
                URL.revokeObjectURL(url);

                document.getElementById('loading').style.display = 'none';
                showAlert('PDF saved successfully!', 'success');
            } catch (error) {
                console.error('Error saving PDF:', error);
                showAlert('Failed to save PDF: ' + error.message, 'error');
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Go back to converter
        function goBack() {
            if (textEdits.length > 0 || annotations.length > 0 || textOverlays.length > 0) {
                showConfirm('You have unsaved changes. Are you sure you want to go back?', (result) => {
                    if (result) {
                        window.location.href = '/';
                    }
                });
            } else {
                window.location.href = '/';
            }
        }

        // Handle opening new PDF file
        document.getElementById('openFileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Function to process the file
            const processFile = async () => {
                // Show loading
                document.getElementById('loading').style.display = 'flex';

                try {
                    // Read file as data URL
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        try {
                            const base64data = event.target.result;

                            // Store in sessionStorage
                            sessionStorage.setItem('pdfToEdit', base64data);
                            sessionStorage.setItem('pdfFileName', file.name);

                            // Reload page to load new PDF
                            window.location.reload();
                        } catch (error) {
                            console.error('Error loading PDF:', error);
                            showAlert('Failed to load PDF: ' + error.message, 'error');
                            document.getElementById('loading').style.display = 'none';
                        }
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    console.error('Error reading file:', error);
                    showAlert('Failed to read file: ' + error.message, 'error');
                    document.getElementById('loading').style.display = 'none';
                }

                // Reset file input
                e.target.value = '';
            };

            // Warn about unsaved changes
            if (textEdits.length > 0 || annotations.length > 0 || textOverlays.length > 0) {
                showConfirm('Opening a new file will discard unsaved changes. Continue?', (result) => {
                    if (result) {
                        processFile();
                    } else {
                        e.target.value = ''; // Reset file input
                    }
                });
            } else {
                processFile();
            }
        });

        // Set default tool
        setTool('editText');

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeEditModal();
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                savePDF();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }
        });

        // Warn user about unsaved changes when closing/navigating away
        window.addEventListener('beforeunload', (e) => {
            // Check if there are any unsaved changes
            if (textEdits.length > 0 || annotations.length > 0 || textOverlays.length > 0) {
                // Standard way to trigger browser's native confirmation dialog
                e.preventDefault();
                e.returnValue = ''; // Required for Chrome

                // Some browsers display this message, others show their own default message
                return 'You have unsaved changes. Are you sure you want to leave?';
            }
        });
    </script>
</body>
</html>
